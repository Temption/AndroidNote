<!DOCTYPE html>
<!-- saved from url=(0045)https://gank.io/post/5e79880393b891c522d3bde6 -->
<html lang="zh-CN" style="transform: none;"><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
    
    <meta name="viewport" content="width=device-width, initial-scale=1.0, minimum-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>干货集中营</title>
    <link rel="stylesheet" href="./干货集中营_files/jimu.css" type="text/css" media="all">
    <link rel="stylesheet" href="./干货集中营_files/style.min.css" type="text/css" media="all">
    <link rel="stylesheet" href="./干货集中营_files/smartideo.css" type="text/css" media="screen">
    <link rel="stylesheet" href="./干货集中营_files/iconfont.css" type="text/css" media="all">
    <link rel="stylesheet" href="./干货集中营_files/nicetheme.css" type="text/css" media="all">
    <link rel="stylesheet" href="./干货集中营_files/new_style.css" type="text/css" media="all">
    <link rel="stylesheet" href="./干货集中营_files/gank.css" type="text/css" media="all">
    <script async="" src="./干货集中营_files/gio.js.下载"></script><script src="./干货集中营_files/hm.js.下载"></script><script type="text/javascript">
        /* <![CDATA[ */
        var globals = {
            "ajax_url": "/admin_ajax",
            "site_url": "/"
        };
        var __ = {
            "load_more": "\u52a0\u8f7d\u66f4\u591a",
            "reached_the_end": "- \u6ca1\u6709\u66f4\u591a\u5185\u5bb9 -",
            "thank_you": "\u8c22\u8c22\u70b9\u8d5e",
            "success": "\u64cd\u4f5c\u6210\u529f",
            "cancelled": "\u53d6\u6d88\u70b9\u8d5e"
        };
        var contribute = {
            "markdown": "0",
            "image_resize": "1",
            "image_drop": "0",
            "magic_url": "1",
            "emoji": "1",
            "__": {
                "unsaved": "\u4ecd\u6709\u5185\u5bb9\u672a\u4fdd\u5b58\uff0c\u60a8\u786e\u5b9a\u8981\u5173\u95ed\u5417\uff1f",
                "title_empty": "\u6587\u7ae0\u6807\u9898\u4e0d\u80fd\u4e3a\u7a7a\uff01",
                "content_empty": "\u6587\u7ae0\u5185\u5bb9\u4e0d\u80fd\u4e3a\u7a7a\uff01",
                "invalid_email": "\u8bf7\u586b\u5199\u6b63\u786e\u7684\u90ae\u7bb1",
                "word_count": "\u603b\u5b57\u6570\uff1a",
                "max_size": "\u4ec5\u5141\u8bb8\u4e0a\u4f20\u56fe\u7247\u6587\u4ef6\u4e14\u5927\u5c0f\u4e0d\u8d85\u8fc7 2M\uff01",
                "type_something": "\u6211\u8981\u5199\u70b9\u4ec0\u4e48\u2026",
                "submit": "\u63d0\u4ea4\u7a3f\u4ef6",
                "draft": "\u4fdd\u5b58\u8349\u7a3f",
                "one_cat": "\u81f3\u5c11\u9009\u62e9\u4e00\u4e2a\u5206\u7c7b\uff01",
                "three_cat": "\u6700\u591a\u9009\u62e9\u4e09\u4e2a\u5206\u7c7b\uff01",
                "required": "\u8bf7\u586b\u5199\u5b8c\u6574\u7248\u6743\u8bf4\u660e"
            }
        };
        /* ]]> */
    </script>
    <script type="text/javascript" src="./干货集中营_files/jquery.js.下载"></script>
    <script type="text/javascript" src="./干货集中营_files/jquery-migrate.min.js.下载"></script>
    <link rel="icon" href="https://gank.io/images/d14678ac6003406f9d9b859341b82c46" sizes="32x32">
    <link rel="icon" href="https://gank.io/images/5f843ad4b78442bbba6bebea8aa7f709" sizes="192x192">
    <link rel="apple-touch-icon-precomposed" href="https://gank.io/images/baf8e246f4bf49bd98858cd857f980ad">
    <meta http-equiv="Content-Security-Policy" content="upgrade-insecure-requests">
    <script type="text/javascript">
    var _hmt = _hmt || [];
    (function () {
        var hm = document.createElement("script");
        hm.src = "https://hm.baidu.com/hm.js?7f507866a71751ec897646c3e2977b48";
        var s = document.getElementsByTagName("script")[0];
        s.parentNode.insertBefore(hm, s);
    })();

    !function (e, t, n, g, i) {
        e[i] = e[i] || function () {
            (e[i].q = e[i].q || []).push(arguments)
        }, n = t.createElement("script"), tag = t.getElementsByTagName("script")[0], n.async = 1, n.src = ('https:' == document.location.protocol ? 'https://' : 'http://') + g, tag.parentNode.insertBefore(n, tag)
    }(window, document, "script", "assets.giocdn.com/2.1/gio.js", "gio");
    gio('init', 'b335f03770a1e4bd', {});

    gio('send');

</script>

<style id="theia-sticky-sidebar-stylesheet-TSS">.theiaStickySidebar:after {content: ""; display: table; clear: both;}</style><script charset="utf-8" src="chrome-extension://jgphnjokjhjlcnnajmfjlacjnjkhleah/js/btype.js"></script><script type="text/javascript" charset="utf-8" src="chrome-extension://jgphnjokjhjlcnnajmfjlacjnjkhleah/js/chrome.js"></script></head>
<body class="home blog logged-in  nice-dark-mode" style="transform: none;">

    <div id="clickCanvas" style=" position:fixed;left:0;top:0;z-index:999999999;pointer-events:none;"><canvas class=" sketch" height="741" width="1698"></canvas></div>

<header class="header">
    <nav class="navbar navbar-expand-lg shadow">
        <div class="container">
            <!-- / brand -->
            <a href="https://gank.io/" rel="home" class="logo navbar-brand order-2 order-lg-1">
                <img src="./干货集中营_files/e04e32fc3d7d4c608282ae3cc8a351bd" class="d-none logo-light nc-no-lazy" alt="干货集中营">
                <img src="./干货集中营_files/aeb0d843f6e548c884016eaac533adef" class="d-inline-block logo-dark nc-no-lazy" alt="干货集中营">
            </a>
            <button class="navbar-toggler order-1" type="button" id="sidebarCollapse">
                <i class="text-xl iconfont icon-menu-line"></i>
            </button>
            <button class="navbar-toggler nav-search order-3 collapsed" data-target="#navbar-search" data-toggle="collapse" aria-expanded="false" aria-controls="navbar-search">
                <i class="text-xl iconfont icon-search-line"></i>
                <i class="text-xl iconfont icon-close-fill"></i>
            </button>
            <!-- brand -->
            <div class="collapse navbar-collapse order-md-2">
                <ul class="navbar-nav main-menu ml-4 mr-auto">
                    <li id="menu-item-14" class="menu-item menu-item-type-custom menu-item-object-custom current-menu-item current_page_item menu-item-home menu-item-14">
                        <a href="https://gank.io/" aria-current="page">首页</a></li>
                    <li id="menu-item-3769" class="menu-item menu-item-type-custom menu-item-object-custom menu-item-3769">
                        <a href="https://gank.io/special/Girl">妹纸</a>
                    </li>
                    <li id="menu-item-1187" class="menu-item menu-item-type-custom menu-item-object-custom menu-item-has-children menu-item-1187"><span class="icon-sub-menu"><i class="iconfont icon-arrow-down-s-line"></i></span>
                        <a>干货</a>
                        <ul class="sub-menu">
                            <li id="menu-item-4451" class="menu-item menu-item-type-post_type menu-item-object-page menu-item-4451"><a href="https://gank.io/ganhuo/Android">Android</a></li>
                            <li id="menu-item-4451" class="menu-item menu-item-type-post_type menu-item-object-page menu-item-4451"><a href="https://gank.io/ganhuo/Flutter">Flutter</a></li>
                            <li id="menu-item-4451" class="menu-item menu-item-type-post_type menu-item-object-page menu-item-4451"><a href="https://gank.io/ganhuo/iOS">iOS</a></li>
                        </ul>
                    </li>
                    <li id="menu-item-1410" class="menu-item menu-item-type-custom menu-item-object-custom menu-item-1410"><a href="https://gank.io/specials">专题</a>
                    </li>
                    
                    
                    
                    
                    
                    
                    
                    
                    
                    
                    
                    
                    <li id="menu-item-1416" class="menu-item menu-item-type-custom menu-item-object-custom menu-item-1416"><a href="https://gank.io/special/Flutter">Flutter</a>
                    </li>
                    <li id="menu-item-1410" class="menu-item menu-item-type-custom menu-item-object-custom menu-item-1410"><a href="https://gank.io/api">API</a>
                    </li>
                    
                    
                    
                    
                    <li id="menu-item-3769" class="menu-item menu-item-type-custom menu-item-object-custom menu-item-3769">
                        <a href="https://gank.io/feedback">留言</a>
                    </li>

                    <li id="menu-item-3769" class="menu-item menu-item-type-custom menu-item-object-custom menu-item-3769">
                        <a href="https://gank.io/migrate_progress">❤新版进度❤</a>
                    </li>
                </ul>
                <ul class="navbar-nav align-items-center order-1 order-lg-2">
                    <li class="nav-item">
                        <a class="btn btn-link btn-icon nav-switch-dark-mode" href="javascript:">
								<span class=" icon-light-mode" data-toggle="tooltip" data-placement="bottom" title="" data-original-title="夜晚模式">
									<i class="text-lg iconfont icon-moon-line"></i>
								</span>
                            <span class="icon-dark-mode" data-toggle="tooltip" data-placement="bottom" title="" data-original-title="日间模式"><i class="text-lg text-warning iconfont icon-moon-fill"></i></span>
                        </a>
                    </li>
                    <li class="nav-item ml-1 ml-md-2">
                        <a class="btn btn-link btn-icon nav-link nav-search collapsed" href="https://gank.io/post/5e79880393b891c522d3bde6#navbar-search" data-toggle="collapse" title="Search" aria-expanded="false" aria-controls="navbar-search">
        <span data-toggle="tooltip" data-placement="bottom" title="" data-original-title="搜索">
            <i class="text-lg iconfont icon-search-line"></i>
            <i class="text-lg iconfont icon-close-fill"></i>
        </span>
                        </a>
                    </li>

                    <li class="nav-item ml-1 ml-md-2">
                        <a class="btn btn-link btn-icon nav-link collapsed" href="https://gank.io/contribute/GanHuo" target="_blank">
                                                    <span data-toggle="tooltip" data-placement="bottom" title="" data-original-title="投稿">
                                                        <i class="text-lg iconfont icon-edit-box-line"></i>
                                                    </span>
                        </a>
                    </li>
                    
                        <div class="btn-group ml-2 ml-md-2" role="group">
                            <a class="btn btn-outline-primary btn-sm" href="https://gank.io/login">注册</a>
                            <a class="btn btn-primary btn-sm" href="https://gank.io/login">登录</a>
                        </div>
                    
                </ul>
            </div>
        </div>
    </nav>
    <div class="mobile-sidebar">

        <!--开启注册登录或者没有开启 apollo 时用下面的-->
        <div class="mobile-sidebar-header">
            <div class="mobile-sidebar-author-cover">
                <div class="media media-2x1">
                    <div class="media-content" style="background-image:url(&#39;/images/0c0a6565322248f7a2d1aff9670ba198&#39;)"></div>
                    <div class="media-overlay overlay-top align-items-center p-3">
                        <!--退出登录按钮-->
                        
                        <div class="flex-fill"></div>
                        <div>
                            <button class="btn btn-icon nav-switch-dark-mode text-white mr-2">
                                <span class="icon-light-mode"><i class="text-xl iconfont icon-moon-line "></i></span>
                                <span class="icon-dark-mode"><i class="text-xl text-warning iconfont icon-moon-fill "></i></span>
                            </button>
                            <button class="btn btn-icon text-white sidebar-close"><span><i class="text-xl iconfont icon-radio-button-line"></i></span></button>
                        </div>
                    </div>
                </div>
            </div>
            <div class="mobile-sidebar-author-body">
                <div class="mobile-sidebar-author-avatar">
                    <a class="flex-avatar mx-2 w-64 border border-2 border-white">
                        
                            <img alt="" src="./干货集中营_files/e2a1d1d58df642c7b5ad976e3f8bc859" class="avatar avatar-64 photo" height="64" width="64">
                        
                    </a>

                </div>
                <div class="mobile-sidebar-author-meta">
                    
                        <div class="h6 mt-2 mb-3"><a href="https://gank.io/login" class="btn btn-outline-primary btn-sm btn-rounded">立即登录</a></div>
                    
                    
                    
                    
                    
                    
                    
                    
                    
                    
                    
                    
                    
                    
                    
                    
                </div>
                
                
                
                
                
                
                
                
                
                
                
                
                
                
                
                
                
                
                
                
                
                
            </div>
        </div>
        <ul class="mobile-sidebar-menu nav flex-column">
            <li class="menu-item menu-item-type-custom menu-item-object-custom current-menu-item current_page_item menu-item-home menu-item-14">
                <a href="https://gank.io/" aria-current="page">首页</a></li>
            <li class="menu-item menu-item-type-custom menu-item-object-custom menu-item-3769">
                <a href="https://gank.io/special/Girl">妹纸</a>
            </li>
            <li class="menu-item menu-item-type-custom menu-item-object-custom menu-item-has-children menu-item-1187">
                <a>干货<div class="dropdown-sub-menu"><span class="iconfont icon-arrow-drop-down-fill"></span></div></a>
                <ul class="sub-menu">
                    <li id="menu-item-4451" class="menu-item menu-item-type-post_type menu-item-object-page menu-item-4451"><a href="https://gank.io/ganhuo/Android">Android</a></li>
                    <li id="menu-item-4451" class="menu-item menu-item-type-post_type menu-item-object-page menu-item-4451"><a href="https://gank.io/ganhuo/Flutter">Flutter</a></li>
                    <li id="menu-item-4451" class="menu-item menu-item-type-post_type menu-item-object-page menu-item-4451"><a href="https://gank.io/ganhuo/iOS">iOS</a></li>
                </ul>
            </li>
            <li class="menu-item menu-item-type-custom menu-item-object-custom menu-item-1410"><a href="https://gank.io/specials">专题</a>
            </li>
            <li class="menu-item menu-item-type-custom menu-item-object-custom menu-item-1416"><a href="https://gank.io/special/Flutter">Flutter</a>
            </li>
            <li class="menu-item menu-item-type-custom menu-item-object-custom menu-item-1410"><a href="https://gank.io/api">API</a>
            </li>
            
            
            
            <li class="menu-item menu-item-type-custom menu-item-object-custom menu-item-3769">
                <a href="https://gank.io/feedback">留言</a>
            </li>
            <li class="menu-item menu-item-type-custom menu-item-object-custom menu-item-3769">
                <a href="https://gank.io/migrate_progress">❤新版进度❤</a>
            </li>

        </ul>
    </div>
    <div class="navbar-search collapse " id="navbar-search" style="">
        <div class="container">
            <form method="get" role="search" id="searchform" class="searchform" action="https://gank.io/search">
                <div class="input-group">
                    <input type="text" name="s" id="s" placeholder="请输入搜索关键词并按回车键…" class="form-control" required="">
                    <div class="input-group-append">
                        <button class="btn btn-nostyle" type="submit"><i class="text-lg iconfont icon-search-line"></i>
                        </button>
                    </div>
                </div><!-- /input-group -->
            </form>
        </div>
    </div>
</header>
<main class="py-3 py-md-5" style="transform: none;">
    <div class="container" style="transform: none;">
        
        <div class="d-none d-md-block breadcrumbs text-muted mb-3">
            <span itemprop="itemListElement">
                <a href="https://gank.io/" itemprop="item" class="home"></a>
            </span>
            <span itemprop="itemListElement">
                <a href="https://gank.io/special/Android" itemprop="item">
                <span itemprop="name">Android</span>
                </a>
            </span>
            <span class="sep">›</span>
            
                
            
            <span class="current">深入探索 Android 内存优化（炼狱级别）</span>
        </div>
        <div class="row no-gutters" style="transform: none;">
            
                <div class="col-lg-8">
    
    <div class="post card">
        <div class="card-body">
            <div class="post-header border-bottom border-light mb-4 pb-4">
                
                <div class="">
                    <a href="https://gank.io/special/Android" target="_blank" class="d-inline-block"><span class="d-block badge badge-primary">#Android#</span></a>
                </div>
                
                <h1 class="h3 mb-3 h-1x">深入探索 Android 内存优化（炼狱级别） </h1>
                
                <div class="meta d-flex align-items-center text-xs text-muted">
                    <div class="d-flex flex-fill align-items-center">
                        <a class="flex-avatar w-16">
                            <img alt="" src="./干货集中营_files/8edfa6bca6c643b3ba3f7cec56780377" class="avatar avatar-16 photo" height="16" width="16"> </a>
                        <time class="d-inline-block">&nbsp;
                            
                                <a class="text-xs">
                                    李金山 </a>
                                &nbsp;发布于&nbsp;10个月前
                            

                        </time>
                    </div>
                    <div class="ml-auto text-sm">
                                    <span class="mx-1"><i class="text-md iconfont icon-eye-line mx-1"></i><small>5653</small></span>
                        <a class="mx-1" href="https://gank.io/post/5e79880393b891c522d3bde6#comments"><i class="text-md iconfont icon-chat--line mx-1"></i><small>0</small></a>
                        <a class=" btn-link-like  mx-1 " href="https://gank.io/login" data-toggle="tooltip" data-placement="top" title="" data-action="like" data-id="5e79880393b891c522d3bde6" data-original-title="请先登录">
                            <i class="text-md iconfont icon-thumb-up-line mx-1"></i><small class="like-count">11</small></a>
                    </div>
                </div>                            <!--<div class="border-theme bg-primary"></div>-->
            </div>
            <div class="post-content">
                <h1 class="heading" data-id="heading-0">前言</h1>
<h3 class="heading" data-id="heading-1">成为一名优秀的Android开发，需要一份完备的<a href="https://github.com/JsonChao/Awesome-Android-Exercise" target="_blank" rel="nofollow noopener noreferrer">知识体系</a>，在这里，让我们一起成长为自己所想的那样~。</h3>
<p>本篇是 Android 内存优化的进阶篇，难度可以说达到了炼狱级别，建议对内存优化不是非常熟悉的仔细看看前篇文章： <a href="https://juejin.im/post/5e72b2d151882549236f9cb8" target="_blank" rel="noopener">Android性能优化之内存优化</a>，其中详细分析了以下几大模块：</p>
<ul>
<li>1）、Android的内存管理机制</li>
<li>2）、优化内存的意义</li>
<li>3）、避免内存泄漏</li>
<li>4）、优化内存空间</li>
<li>5）、图片管理模块的设计与实现</li>
</ul>
<p>如果你对以上基础内容都比较了解了，那么我们便开始 Android 内存优化的探索之旅吧。</p>
<blockquote>
<p>本篇文章非常长，建议收藏后慢慢享用~</p>
</blockquote>
<h1 class="heading" data-id="heading-2">思维导图大纲</h1>
<figure><img class="lazyload" src="./干货集中营_files/b09c47d68e574843ae5b2908727d6570" data-height="900" data-width="1280">
<figcaption></figcaption>
</figure>
<h1 class="heading" data-id="heading-4">一、重识内存优化</h1>
<p>Android给每个应用进程分配的内存都是非常有限的，那么，<strong>为什么不能把图片下载下来都放到磁盘中呢</strong>？那是因为放在 <strong>内存</strong> 中，展示会更 “<strong>快</strong>”，快的原因有两点，如下所示：</p>
<ul>
<li>1）、<strong>硬件快</strong>：内存本身读取、存入速度快。</li>
<li>2）、<strong>复用快</strong>：解码成果有效保存，复用时，直接使用解码后对象，而不是再做一次图像解码。</li>
</ul>
<p>这里说一下解码的概念。Android系统要在屏幕上展示图片的时候只认 “<strong>像素缓冲</strong>”，而这也是大多数操作系统的特征。而我们 <strong>常见的jpg，png等图片格式，都是把 “像素缓冲” 使用不同的手段压缩后的结果</strong>，所以这些格式的图片，要在设备上 <strong>展示</strong>，就 <strong>必须经过一次解码</strong>，它的 <strong>执行速度会受图片压缩比、尺寸等因素影响</strong>。(官方建议：<strong>把从内存中淘汰的图片，降低压缩比后存储到本地，以备后用，这样可以最大限度地降低以后复用时的解码开销</strong>。)</p>
<p>下面，我们来了解一下内存优化的一些重要概念。</p>
<h2 class="heading" data-id="heading-5">1、手机RAM</h2>
<p>手机不使用 <strong>PC</strong> 的 <strong>DDR内存</strong>，采用的是 <strong>LPDDR RAM</strong>，即 ”<strong>低功耗双倍数据速率内存</strong>“。其计算规则如下所示：</p>
<pre><code class="copyable">LPDDR系列的带宽 = 时钟频率 ✖️内存总线位数 / 8
LPDDR4 = 1600MHZ ✖️64 / 8 ✖️双倍速率 = 25.6GB/s。
<span class="copy-code-btn">复制代码</span></code></pre>
<h3 class="heading" data-id="heading-6">那么内存占用是否越少越好？</h3>
<p>当系统 <strong>内存充足</strong> 的时候，我们可以 <strong>多用</strong> 一些获得 <strong>更好的性能</strong>。当系统 <strong>内存不足</strong> 的时候，我们希望可以做到 ”<strong>用时分配，及时释放</strong>“。</p>
<h2 class="heading" data-id="heading-7">2、内存优化的纬度</h2>
<p>对于Android内存优化来说又可以细分为如下两个维度，如下所示：</p>
<ul>
<li>1）、<strong>RAM优化</strong></li>
<li>2）、<strong>ROM优化</strong></li>
</ul>
<h3 class="heading" data-id="heading-8">1、RAM优化</h3>
<p>主要是 <strong>降低运行时内存</strong>。它的 <strong>目的</strong> 有如下三个：</p>
<ul>
<li><strong>1）、防止应用发生OOM</strong>。</li>
<li><strong>2）、降低应用由于内存过大被LMK机制杀死的概率</strong>。</li>
<li><strong>3）、避免不合理使用内存导致GC次数增多，从而导致应用发生卡顿</strong>。</li>
</ul>
<h3 class="heading" data-id="heading-9">2、ROM优化</h3>
<p>降低应用占ROM的体积，进行APK瘦身。它的 <strong>目的</strong> 主要是为了 <strong>降低应用占用空间，避免因ROM空间不足导致程序无法安装</strong>。</p>
<h2 class="heading" data-id="heading-10">3、内存问题</h2>
<p>那么，内存问题主要是有哪几类呢？内存问题通常来说，可以细分为如下 <strong>三类</strong>:</p>
<ul>
<li>1）、<strong>内存抖动</strong></li>
<li>2）、<strong>内存泄漏</strong></li>
<li>3）、<strong>内存溢出</strong></li>
</ul>
<p>下面，我们来了解下它们。</p>
<h3 class="heading" data-id="heading-11">1、内存抖动</h3>
<p>内存波动图形呈 <strong>锯齿张</strong>、<strong>GC导致卡顿</strong>。</p>
<p>这个问题在 <strong>Dalvik虚拟机</strong> 上会 <strong>更加明显</strong>，而 <strong>ART虚拟机</strong> 在 <strong>内存管理跟回收策略</strong> 上都做了 <strong>大量优化</strong>，<strong>内存分配和GC效率相比提升了5~10倍</strong>，所以 <strong>出现内存抖动的概率会小很多</strong>。</p>
<h3 class="heading" data-id="heading-12">2、内存泄漏</h3>
<p>Android系统虚拟机的垃圾回收是通过虚拟机GC机制来实现的。GC会选择一些还存活的对象作为内存遍历的根节点GC Roots，通过对GC Roots的可达性来判断是否需要回收。内存泄漏就是 <strong>在当前应用周期内不再使用的对象被GC Roots引用，导致不能回收，使实际可使用内存变小</strong>。简言之，就是 <strong>对象被持有导致无法释放或不能按照对象正常的生命周期进行释放</strong>。一般来说，<strong>可用内存减少、频繁GC，容易导致内存泄漏</strong>。</p>
<h3 class="heading" data-id="heading-13">3、内存溢出</h3>
<p>即OOM，OOM时会导致程序异常。Android设备出厂以后，java虚拟机对单个应用的最大内存分配就确定下来了，超出这个值就会OOM。<strong>单个应用可用的最大内存对应于 /system/build.prop 文件中的 dalvik.vm.heapgrowthlimit</strong>。</p>
<p>此外，除了因内存泄漏累积到一定程度导致OOM的情况以外，也有一次性申请很多内存，比如说 <strong>一次创建大的数组或者是载入大的文件如图片的时候会导致OOM</strong>。而且，实际情况下 <strong>很多OOM就是因图片处理不当</strong> 而产生的。</p>
<h1 class="heading" data-id="heading-14">二、常见工具选择</h1>
<p>在 <a href="https://juejin.im/post/5e72b2d151882549236f9cb8#heading-24" target="_blank" rel="noopener">Android性能优化之内存优化</a> 中我们已经介绍过了相关的优化工具，这里再简单回顾一下。</p>
<h2 class="heading" data-id="heading-15">1、Memory Profiler</h2>
<h3 class="heading" data-id="heading-16">作用</h3>
<ul>
<li>1）、<strong>实时图表展示应用内存使用量</strong>。</li>
<li>2）、<strong>用于识别内存泄漏、抖动等</strong>。</li>
<li>3）、<strong>提供捕获堆转储、强制GC以及根据内存分配的能力</strong>。</li>
</ul>
<h3 class="heading" data-id="heading-17">优点</h3>
<ul>
<li>1）、<strong>方便直观</strong></li>
<li>2）、<strong>线下使用</strong></li>
</ul>
<h2 class="heading" data-id="heading-18">2、Memory Analyzer</h2>
<p>强大的 <strong>Java Heap</strong> 分析工具，查找 <strong>内存泄漏及内存占用</strong>， 生成 <strong>整体报告</strong>、<strong>分析内存问题</strong> 等等。建议 <strong>线下深入使用</strong>。</p>
<h2 class="heading" data-id="heading-19">3、LeakCanary</h2>
<p><strong>自动化</strong> 内存泄漏检测神器。建议仅用于<strong>线下集成</strong>。</p>
<p>它的 <strong>缺点</strong> 比较明显，具体有如下两点：</p>
<ul>
<li>1）、虽然使用了 <strong>idleHandler与多进程</strong>，但是 <strong>dumphprof 的 SuspendAll Thread 的特性依然会导致应用卡顿</strong>。</li>
<li>2）、<strong>在三星等手机，系统会缓存最后一个Activity，此时应该采用更严格的检测模式</strong>。</li>
</ul>
<h1 class="heading" data-id="heading-20">三、Android内存管理机制回顾</h1>
<p>ART 和 Dalvik 虚拟机使用 <strong>分页和内存映射</strong> 来管理内存。下面我们先从Java的内存分配开始说起。</p>
<h2 class="heading" data-id="heading-21">1、Java 内存分配</h2>
<p>Java的 <strong>内存分配区域</strong> 分为如下 <strong>五部分</strong>：</p>
<ul>
<li><strong>1）、方法区：主要存放静态常量</strong>。</li>
<li><strong>2）、虚拟机栈：Java变量引用</strong>。</li>
<li><strong>3）、本地方法栈：native变量引用</strong>。</li>
<li><strong>4）、堆：对象</strong>。</li>
<li><strong>5）、程序计数器：计算当前线程的当前方法执行到多少行</strong>。</li>
</ul>
<h2 class="heading" data-id="heading-22">2、Java 内存回收算法</h2>
<h3 class="heading" data-id="heading-23">1、标记-清除算法</h3>
<p>流程可简述为 <strong>两步</strong>：</p>
<ul>
<li><strong>1）、标记所有需要回收的对象</strong>。</li>
<li><strong>2）、统一回收所有被标记的对象</strong>。</li>
</ul>
<h4 class="heading" data-id="heading-24">优点</h4>
<p>实现比较简单。</p>
<h4 class="heading" data-id="heading-25">缺点</h4>
<ul>
<li>1）、标记、清除<strong>效率不高</strong>。</li>
<li>2）、产生<strong>大量内存碎片</strong>。</li>
</ul>
<h3 class="heading" data-id="heading-26">2、复制算法</h3>
<p>流程可简述为 <strong>三步</strong>：</p>
<ul>
<li><strong>1）、将内存划分为大小相等的两块</strong>。</li>
<li><strong>2）、一块内存用完之后复制存活对象到另一块</strong>。</li>
<li><strong>3）、清理另一块内存</strong>。</li>
</ul>
<h4 class="heading" data-id="heading-27">优点</h4>
<p>实现简单，运行高效，<strong>每次仅需遍历标记一半的内存区域</strong>。</p>
<h4 class="heading" data-id="heading-28">缺点</h4>
<p>会<strong>浪费一半的空间</strong>，代价大。</p>
<h3 class="heading" data-id="heading-29">3、标记-整理算法</h3>
<p>流程可简述为 <strong>三步</strong>：</p>
<ul>
<li><strong>1）、标记过程与 标记-清除算法 一样</strong>。</li>
<li><strong>2）、存活对象往一端进行移动</strong>。</li>
<li><strong>3）、清理其余内存</strong>。</li>
</ul>
<h4 class="heading" data-id="heading-30">优点</h4>
<ul>
<li><strong>1）、避免 标记-清除 导致的内存碎片</strong>。</li>
<li><strong>2）、避免复制算法的空间浪费</strong>。</li>
</ul>
<h3 class="heading" data-id="heading-31">4、分代收集算法</h3>
<p>现在 <strong>主流的虚拟机</strong> 一般用的比较多的还是分代收集算法，它具有如下 <strong>特点</strong>：</p>
<ul>
<li><strong>1）、结合多种算法优势</strong>。</li>
<li><strong>2）、新生代对象存活率低，使用 复制算法</strong>。</li>
<li><strong>3）、老年代对象存活率高，使用 标记-整理算法</strong>。</li>
</ul>
<h2 class="heading" data-id="heading-32">3、Android 内存管理机制</h2>
<p>Android 中的内存是 <strong>弹性分配</strong> 的，<strong>分配值 与 最大值 受具体设备影响</strong>。</p>
<p>对于 <strong>OOM场景</strong> 其实可以细分为如下两种：</p>
<ul>
<li><strong>1）、内存真正不足</strong>。</li>
<li><strong>2）、可用（被分配的）内存不足</strong>。</li>
</ul>
<p>我们需要着重注意一下这两种的区分。</p>
<h2 class="heading" data-id="heading-33">4、小结</h2>
<p>以Android中虚拟机的角度来说，我们要清楚 <strong>Dalvik 与 ART 区别</strong>，<strong>Dalvik</strong> 仅固定<strong>一种回收算法</strong>，而 <strong>ART</strong> 回收算法可在 <strong>运行期按需选择</strong>，并且，<strong>ART</strong> 具备 <strong>内存整理</strong> 能力，<strong>减少内存空洞</strong>。</p>
<p>最后，<strong>LMK（Low Memory killer）</strong> 机制保证了<strong>进程资源的合理利用</strong>，它的<strong>实现原理</strong>主要是 <strong>根据进程分类和回收收益来综合决定的一套算法集</strong>。</p>
<h1 class="heading" data-id="heading-34">四、内存抖动</h1>
<p>当 <strong>内存频繁分配和回收</strong> 导致内存 <strong>不稳定</strong>，就会出现内存抖动，它通常表现为 <strong>频繁GC、内存曲线呈锯齿状</strong>。</p>
<p>并且，它的危害也很严重，通常会导致 <strong>页面卡顿</strong>，甚至造成 <strong>OOM</strong>。</p>
<h2 class="heading" data-id="heading-35">1、那么，为什么内存抖动会导致 OOM？</h2>
<p>主要原因有如下两点：</p>
<ul>
<li>1）、<strong>频繁创建对象，导致内存不足及碎片（不连续）</strong>。</li>
<li>2）、<strong>不连续的内存片无法被分配，导致OOM</strong>。</li>
</ul>
<h2 class="heading" data-id="heading-36">2、内存抖动解决实战</h2>
<p>这里我们假设有这样一个场景：点击按钮使用 handler 发送一个空消息，handler 的 handleMessage 接收到消息后创建内存抖动，即在 for 循环创建 100个容量为10万 的 strings 数组并在 30ms 后继续发送空消息。</p>
<p>一般使用 <strong>Memory Profiler （表现为 频繁GC、内存曲线呈锯齿状）结合代码排查</strong>即可找到内存抖动出现的地方。</p>
<p>通常的技巧就是着重查看 <strong>循环或频繁被调用</strong> 的地方。</p>
<h2 class="heading" data-id="heading-37">3、内存抖动常见案例</h2>
<p>下面列举一些导致内存抖动的常见案例，如下所示：</p>
<h3 class="heading" data-id="heading-38">1、字符串使用加号拼接</h3>
<ul>
<li>1）、<strong>使用StringBuilder替代</strong>。</li>
<li>2）、<strong>初始化时设置容量，减少StringBuilder的扩容</strong>。</li>
</ul>
<h3 class="heading" data-id="heading-39">2、资源复用</h3>
<ul>
<li>1）、使用 <strong>全局缓存池</strong>，以 <strong>重用频繁申请和释放的对象</strong>。</li>
<li>2）、注意 <strong>结束</strong> 使用后，需要 <strong>手动释放对象池中的对象</strong>。</li>
</ul>
<h3 class="heading" data-id="heading-40">3、减少不合理的对象创建</h3>
<ul>
<li>1）、<strong>ondraw、getView 中创建的对象尽量进行复用</strong>。</li>
<li>2）、<strong>避免在循环中不断创建局部变量</strong>。</li>
</ul>
<h3 class="heading" data-id="heading-41">4、使用合理的数据结构</h3>
<p>使用 <strong>SparseArray类族、ArrayMap</strong> 来替代 <strong>HashMap</strong>。</p>
<h1 class="heading" data-id="heading-42">五、内存优化体系化搭建</h1>
<p>在开始我们今天正式的主题之前，我们先来回归一下内存泄漏的概念与解决技巧。</p>
<p>所谓的内存泄漏就是 <strong>内存中存在已经没有用的对象</strong>。它的 <strong>表现</strong> 一般为 <strong>内存抖动、可用内存逐渐减少</strong>。 它的 <strong>危害</strong> 即会导致 <strong>内存不足、GC频繁、OOM</strong>。</p>
<p>而对于 <strong>内存泄漏的分析</strong> 一般可简述为如下 <strong>两步</strong>：</p>
<ul>
<li>1）、<strong>使用 Memory Profiler 初步观察</strong>。</li>
<li>2）、<strong>通过 Memory Analyzer 结合代码确认</strong>。</li>
</ul>
<h2 class="heading" data-id="heading-43">1、MAT回顾</h2>
<h3 class="heading" data-id="heading-44">MAT查找内存泄漏</h3>
<p>对于MAT来说，其常规的查找内存泄漏的方式可以细分为如下三步：</p>
<ul>
<li>1）、首先，<strong>找到当前 Activity，在 Histogram 中选择其 List Objects 中的 with incoming reference（哪些引用引向了我）</strong>。</li>
<li>2）、然后，<strong>选择当前的一个 Path to GC Roots/Merge to GC Roots 的 exclude All 弱软虚引用</strong>。</li>
<li>3）、最后，<strong>找到的泄漏对象在左下角下会有一个小圆圈</strong>。</li>
</ul>
<p>此外，在 <a href="https://juejin.im/post/5e72b2d151882549236f9cb8" target="_blank" rel="noopener">Android性能优化之内存优化</a> 还有几种进阶的使用方式，这里就不一一赘述了，下面，我们来看看关于 MAT 使用时的一些关键细节。</p>
<h3 class="heading" data-id="heading-45">MAT的关键使用细节</h3>
<p>要全面掌握MAT的用法，必须要先了解 <strong>隐藏在 MAT 使用中的四大细节</strong>，如下所示：</p>
<ul>
<li>1）、<strong>善于使用 Regex 查找对应泄漏类</strong>。</li>
<li>2）、<strong>使用 group by package 查找对应包下的具体类</strong>。</li>
<li>3）、<strong>明白 with outgoing references 和 with incoming references 的区别</strong>。
<ul>
<li><strong>with outgoing references：它引用了哪些对象</strong>。</li>
<li><strong>with incoming references：哪些对象引用了它</strong>。</li>
</ul>
</li>
<li>4）、<strong>了解 Shallow Heap 和 Retained Heap 的区别</strong>。
<ul>
<li><strong>Shallow Heap：表示对象自身占用的内存</strong>。</li>
<li><strong>Retained Heap：对象自身占用的内存 + 对象引用的对象所占用的内存</strong>。</li>
</ul>
</li>
</ul>
<h3 class="heading" data-id="heading-46">MAT 关键组件回顾</h3>
<p>除此之外，MAT 共有 <strong>5个关键组件</strong> 帮助我们去分析内存方面的问题，分别如下所示：</p>
<ul>
<li>1）、<strong>Dominator_tree</strong></li>
<li>2）、<strong>Histogram</strong></li>
<li>3）、<strong>thread_overview</strong></li>
<li>4）、<strong>Top Consumers</strong></li>
<li>5）、<strong>Leak Suspects</strong></li>
</ul>
<p>下面我们这里再简单地回顾一下它们。</p>
<h4 class="heading" data-id="heading-47">1、Dominator（支配者）：</h4>
<p>如果从GC Root到达对象A的路径上必须经过对象B，那么B就是A的支配者。</p>
<h4 class="heading" data-id="heading-48">2、Histogram和dominator_tree的区别：</h4>
<ul>
<li>1）、Histogram 显示 Shallow Heap、Retained Heap、<strong>Objects</strong>，而 dominator_tree 显示的是 Shallow Heap、Retained Heap、<strong>Percentage</strong>。</li>
<li>2）、Histogram 基于 <strong>类</strong> 的角度，dominator_tree是基于 <strong>实例</strong> 的角度。<strong>Histogram 不会具体显示每一个泄漏的对象，而dominator_tree会</strong>。</li>
</ul>
<h4 class="heading" data-id="heading-49">3、thread_overview</h4>
<p>查看 <strong>线程数量</strong> 和 <strong>线程的 Shallow Heap、Retained Heap、Context Class Loader 与 is Daemon</strong>。</p>
<h4 class="heading" data-id="heading-50">4、Top Consumers</h4>
<p>通过 <strong>图形</strong> 的形式列出 <strong>占用内存比较多的对象</strong>。</p>
<p>在下方的 <strong>Biggest Objects</strong> 还可以查看其 <strong>相对比较详细的信息</strong>，例如 <strong>Shallow Heap、Retained Heap</strong>。</p>
<h4 class="heading" data-id="heading-51">5、Leak Suspects</h4>
<p><strong>列出有内存泄漏的地方，点击 Details 可以查看其产生内存泄漏的引用链</strong>。</p>
<h2 class="heading" data-id="heading-52">2、搭建体系化的图片优化 / 监控机制</h2>
<p>在介绍图片监控体系的搭建之前，首先我们来回顾下 <strong>Android Bitmap 内存分配的变化</strong>。</p>
<h3 class="heading" data-id="heading-53">Android Bitmap 内存分配的变化</h3>
<h4 class="heading" data-id="heading-54">在Android 3.0之前</h4>
<ul>
<li>1）、<strong>Bitmap 对象存放在 Java Heap，而像素数据是存放在 Native 内存中的</strong>。</li>
<li>2）、<strong>如果不手动调用 recycle，Bitmap Native 内存的回收完全依赖 finalize 函数回调，但是回调时机是不可控的</strong>。</li>
</ul>
<h4 class="heading" data-id="heading-55">Android 3.0 ~ Android 7.0</h4>
<p>将 <strong>Bitmap对象</strong> 和 <strong>像素数据</strong> 统一放到 <strong>Java Heap</strong> 中，即使不调用 recycle，Bitmap 像素数据也会随着对象一起被回收。</p>
<p>但是，Bitmap 全部放在 Java Heap 中的缺点很明显，大致有如下两点：</p>
<ul>
<li>1）、<strong>Bitmap是内存消耗的大户，而 Max Java Heap 一般限制为 256、512MB，Bitmap 过大过多容易导致 OOM</strong>。</li>
<li>2）、<strong>容易引起大量 GC，没有充分利用系统的可用内存</strong>。</li>
</ul>
<h4 class="heading" data-id="heading-56">Android 8.0及以后</h4>
<ul>
<li>1）、<strong>使用了能够辅助回收 Native 内存的 <a href="https://www.androidos.net.cn/android/8.0.0_r4/xref/libcore/luni/src/main/java/libcore/util/NativeAllocationRegistry.java" target="_blank" rel="nofollow noopener noreferrer">NativeAllocationRegistry</a>，以实现将像素数据放到 Native 内存中，并且可以和 Bitmap 对象一起快速释放，最后，在 GC 的时候还可以考虑到这些 Bitmap 内存以防止被滥用</strong>。</li>
<li>2）、Android 8.0 为了 <strong>解决图片内存占用过多和图像绘制效率过慢</strong> 的问题新增了 <strong><a href="https://blog.csdn.net/weixin_34208185/article/details/88032954" target="_blank" rel="nofollow noopener noreferrer">硬件位图 Hardware Bitmap</a></strong>。</li>
</ul>
<h3 class="heading" data-id="heading-57">那么，我们如何将图片内存存放在 Native 中呢？</h3>
<p>将图片内存存放在Native中的步骤有 <strong>四步</strong>，如下所示：</p>
<ul>
<li>1）、<strong>调用 libandroid_runtime.so 中的 Bitmap 构造函数，申请一张空的 Native Bitmap。对于不同 Android 版本而言，这里的获取过程都有一些差异需要适配</strong>。</li>
<li>2）、<strong>申请一张普通的 Java Bitmap</strong>。</li>
<li>3）、<strong>将 Java Bitmap 的内容绘制到 Native Bitmap 中</strong>。</li>
<li>4）、<strong>释放 Java Bitmap 内存</strong>。</li>
</ul>
<p>我们都知道的是，当 <strong>系统内存不足</strong> 的时候，<strong>LMK</strong> 会根据 <strong>OOM_adj</strong> 开始杀进程，从 <strong>后台、桌面、服务、前台，直到手机重启</strong>。并且，如果频繁申请释放 Java Bitmap 也很容易导致内存抖动。对于这种种问题，我们该 <strong>如何评估内存对应用性能的影响</strong> 呢？</p>
<p>对此，我们可以主要从以下 <strong>两个方面</strong> 进行评估，如下所示：</p>
<ul>
<li>1）、<strong>崩溃中异常退出和 OOM 的比例</strong>。</li>
<li>2）、<strong>低内存设备更容易出现内存不足和卡顿，需要查看应用中用户的手机内存在 2GB 以下所占的比例</strong>。</li>
</ul>
<p>对于具体的优化策略与手段，我们可以从以下 <strong>七个方面</strong> 来搭建一套 <strong>成体系化的图片优化 / 监控机制</strong>。</p>
<h3 class="heading" data-id="heading-58">1、统一图片库</h3>
<p>在项目中，我们需要 <strong>收拢图片的调用，避免使用 Bitmap.createBitmap、BitmapFactory 相关的接口创建 Bitmap，而应该使用自己的图片框架</strong>。</p>
<h3 class="heading" data-id="heading-59">2、设备分级优化策略</h3>
<p>内存优化首先需要根据 <strong>设备环境</strong> 来综合考虑，<strong>让高端设备使用更多的内存</strong>，做到 <strong>针对设备性能的好坏使用不同的内存分配和回收策略</strong>。</p>
<p>因此，我们可以使用类似 <a href="https://github.com/facebookarchive/device-year-class" target="_blank" rel="nofollow noopener noreferrer">device-year-class</a> 的策略对设备进行分级，<strong>对于低端机用户可以关闭复杂的动画或”重功能“，使用565格式的图片或更小的缓存内存</strong> 等等。</p>
<p>业务开发人员需要 <strong>考虑功能是否对低端机开启，在系统资源不够时主动去做降级处理</strong>。</p>
<h3 class="heading" data-id="heading-60">3、建立统一的缓存管理组件</h3>
<p><strong>建立统一的缓存管理组件（参考 <a href="https://github.com/yangfuhai/ASimpleCache" target="_blank" rel="nofollow noopener noreferrer">ACache</a>），并合理使用 OnTrimMemory / LowMemory 回调，根据系统不同的状态去释放相应的缓存与内存</strong>。</p>
<p>在实现过程中，需要 <strong>解决使用 static LRUCache 来缓存大尺寸 Bitmap 的问题</strong>。</p>
<p>并且，在通过实际的测试后，发现 <strong>onTrimMemory 的 ComponetnCallbacks2.TRIM_MEMORY_COMPLETE 并不等价于 onLowMemory，因此建议仍然要去监听 onLowMemory 回调</strong>。</p>
<h3 class="heading" data-id="heading-61">4、低端机避免使用多进程</h3>
<p>一个 <strong>空进程</strong> 也会占用 <strong>10MB</strong> 内存，低端机应该尽可能减少使用多进程。</p>
<p>针对低端机用户可以推出 <strong>4MB 的轻量级版本</strong>，如今日头条极速版、Facebook Lite。</p>
<h3 class="heading" data-id="heading-62">5、线下大图片检测</h3>
<p><strong>在开发过程中，如果检测到不合规的图片使用（如图片宽度超过View的宽度甚至屏幕宽度），应该立刻提示图片所在的Activity和堆栈，让开发人员更快发现并解决问题。在灰度和线上环境，可以将异常信息上报到后台，还可以计算超宽率（图片超过屏幕大小所占图片总数的比例）</strong>。</p>
<p>下面，我们介绍下如何实现对大图片的检测。</p>
<h4 class="heading" data-id="heading-63">常规实现</h4>
<p>继承 ImageView，重写实现计算图片大小。但是侵入性强，并且不通用。</p>
<p>因此，这里我们介绍一种更好的方案：ARTHook。</p>
<h4 class="heading" data-id="heading-64">ARTHook优雅检测大图</h4>
<p><strong>ARTHook</strong>，即 <strong>挂钩，用额外的代码勾住原有的方法，以修改执行逻辑</strong>，主要可以用于以下四个方面：</p>
<ul>
<li>1）、<strong>AOP编程</strong></li>
<li>2）、<strong>运行时插桩</strong></li>
<li>3）、<strong>性能分析</strong></li>
<li>4）、<strong>安全审计</strong></li>
</ul>
<p>具体我们是使用 <strong>Epic</strong> 来进行 Hook，Epic 是 <strong>一个虚拟机层面，以 Java 方法为粒度的运行时 Hook 框架</strong>。简单来说，它就是 <strong>ART 上的 Dexposed</strong>，并且它目前 <strong>支持 Android 4.0~10.0</strong>。</p>
<p><a href="https://github.com/tiann/epic/blob/master/README_cn.md" target="_blank" rel="nofollow noopener noreferrer">Epic github 地址</a></p>
<h5 class="heading" data-id="heading-65">使用步骤</h5>
<p>Epic通常的使用步骤为如下三个步骤：</p>
<p>1、在项目 moudle 的 build.gradle 中添加</p>
<pre><code class="copyable">compile 'me.weishu:epic:0.6.0'
<span class="copy-code-btn">复制代码</span></code></pre>
<p>2、继承 XC_MethodHook，实现 Hook 方法前后的逻辑。如 <strong>监控Java线程的创建和销毁</strong>：</p>
<pre><code class="copyable">class ThreadMethodHook extends XC_MethodHook{
    @Override
    protected void beforeHookedMethod(MethodHookParam param) throws Throwable {
        super.beforeHookedMethod(param);
        Thread t = (Thread) param.thisObject;
        Log.i(TAG, "thread:" + t + ", started..");
    }

    @Override
    protected void afterHookedMethod(MethodHookParam param) throws Throwable {
        super.afterHookedMethod(param);
        Thread t = (Thread) param.thisObject;
        Log.i(TAG, "thread:" + t + ", exit..");
    }
}
<span class="copy-code-btn">复制代码</span></code></pre>
<p>3、注入 Hook 好的方法：</p>
<pre><code class="copyable">DexposedBridge.findAndHookMethod(Thread.class, "run", new ThreadMethodHook());
<span class="copy-code-btn">复制代码</span></code></pre>
<p>知道了 Epic 的基本使用方法之后，我们便可以利用它来实现大图片的监控报警了。</p>
<h5 class="heading" data-id="heading-66">项目实战</h5>
<p>以 <a href="https://github.com/JsonChao/Awesome-WanAndroid" target="_blank" rel="nofollow noopener noreferrer">Awesome-WanAndroid</a> 项目为例，首先，在 WanAndroidApp 的 onCreate 方法中添加如下代码：</p>
<pre><code class="copyable">DexposedBridge.hookAllConstructors(ImageView.class, new XC_MethodHook() {
        @Override
        protected void afterHookedMethod(MethodHookParam param) throws Throwable {
            super.afterHookedMethod(param);
        // 1
        DexposedBridge.findAndHookMethod(ImageView.class, "setImageBitmap", Bitmap.class, new ImageHook());
        }
    });
<span class="copy-code-btn">复制代码</span></code></pre>
<p>在注释1处，我们 <strong>通过调用 DexposedBridge 的 findAndHookMethod 方法找到所有通过 ImageView 的 setImageBitmap 方法设置的切入点</strong>，其中最后一个参数 ImageHook 对象是继承了 XC_MethodHook 类，其目的是为了 <strong>重写 afterHookedMethod 方法拿到相应的参数进行监控逻辑的判断</strong>。</p>
<p>接下来，我们来实现我们的 ImageHook 类，代码如下所示：</p>
<pre><code class="copyable">public class ImageHook extends XC_MethodHook {

    @Override
    protected void afterHookedMethod(MethodHookParam param) throws Throwable {
        super.afterHookedMethod(param);
        // 1
        ImageView imageView = (ImageView) param.thisObject;
        checkBitmap(imageView,((ImageView) param.thisObject).getDrawable());
    }


    private static void checkBitmap(Object thiz, Drawable drawable) {
        if (drawable instanceof BitmapDrawable &amp;&amp; thiz instanceof View) {
            final Bitmap bitmap = ((BitmapDrawable) drawable).getBitmap();
            if (bitmap != null) {
                final View view = (View) thiz;
                int width = view.getWidth();
                int height = view.getHeight();
                if (width &gt; 0 &amp;&amp; height &gt; 0) {
                    // 2、图标宽高都大于view的2倍以上，则警告
                    if (bitmap.getWidth() &gt;= (width &lt;&lt; 1)
                        &amp;&amp;  bitmap.getHeight() &gt;= (height &lt;&lt; 1)) {
                    warn(bitmap.getWidth(), bitmap.getHeight(), width, height, new RuntimeException("Bitmap size too large"));
                }
                } else {
                    // 3、当宽高度等于0时，说明ImageView还没有进行绘制，使用ViewTreeObserver进行大图检测的处理。
                    final Throwable stackTrace = new RuntimeException();
                    view.getViewTreeObserver().addOnPreDrawListener(new ViewTreeObserver.OnPreDrawListener() {
                        @Override
                        public boolean onPreDraw() {
                            int w = view.getWidth();
                            int h = view.getHeight();
                            if (w &gt; 0 &amp;&amp; h &gt; 0) {
                                if (bitmap.getWidth() &gt;= (w &lt;&lt; 1)
                                    &amp;&amp; bitmap.getHeight() &gt;= (h &lt;&lt; 1)) {
                                    warn(bitmap.getWidth(), bitmap.getHeight(), w, h, stackTrace);
                                }
                                view.getViewTreeObserver().removeOnPreDrawListener(this);
                            }
                            return true;
                        }
                    });
                }
            }
        }
    }

    private static void warn(int bitmapWidth, int bitmapHeight, int viewWidth, int viewHeight, Throwable t) {
        String warnInfo = "Bitmap size too large: " +
            "\n real size: (" + bitmapWidth + ',' + bitmapHeight + ')' +
            "\n desired size: (" + viewWidth + ',' + viewHeight + ')' +
            "\n call stack trace: \n" + Log.getStackTraceString(t) + '\n';

        LogHelper.i(warnInfo);
    }
}
<span class="copy-code-btn">复制代码</span></code></pre>
<p>首先，在注释1处，我们<strong>重写了 ImageHook 的 afterHookedMethod 方法，拿到了当前的 ImageView 和要设置的 Bitmap 对象</strong>。然后，在注释2处，<strong>如果当前 ImageView 的宽高大于0，我们便进行大图检测的处理：ImageView 的宽高都大于 View 的2倍以上，则警告</strong>。接着，在注释3处，<strong>如果当前 ImageView 的宽高等于0，则说明 ImageView 还没有进行绘制，则使用 ImageView 的 ViewTreeObserver 获取其宽高进行大图检测的处理</strong>。至此，我们的大图检测检测组件就已经实现了。</p>
<h5 class="heading" data-id="heading-67">ARTHook方案实现小结</h5>
<ul>
<li>1）、<strong>无侵入性</strong></li>
<li>2）、<strong>通用性强</strong></li>
<li>3）、<strong>兼容性问题大，开源方案不能带到线上环境</strong>。</li>
</ul>
<h3 class="heading" data-id="heading-68">6、线下重复图片检测</h3>
<p><a href="https://github.com/JsonChao/Chapter04" target="_blank" rel="nofollow noopener noreferrer">已完全配置好的项目请参见这里</a></p>
<p>首先我们来了解一下这里的 <strong>重复图片</strong> 所指的概念： 即 <strong>Bitmap 像素数据完全一致，但是有多个不同的对象存在</strong>。</p>
<p><strong>重复图片检测的原理其实就是 使用内存 Hprof 分析工具，自动将重复 Bitmap 的图片和引用堆栈输出</strong>。</p>
<h4 class="heading" data-id="heading-69">实现步骤</h4>
<p>具体的实现可以细分为如下三个步骤：</p>
<ul>
<li>1）、首先，<strong>获取 android.graphics.Bitmap 实例对象的 mBuffer 作为 ArrayInstance ，通过 getValues 获取的数据为 Object 类型</strong>。由于后面计算 md5 需要为 byte[] 类型，所以<strong>通过反射的方式调用 ArrayInstance#asRawByteArray 直接返回 byte[] 数据</strong>。</li>
<li>2）、然后，<strong>根据 mBuffer 的数据生成 png 图片文件</strong>，这里直接参考了 <a href="https://github.com/JetBrains/adt-tools-base/blob/master/ddmlib/src/main/java/com/android/ddmlib/BitmapDecoder.java" target="_blank" rel="nofollow noopener noreferrer">github.com/JetBrains/a…</a> 的实现方式。</li>
<li>3）、最后，<strong>获取堆栈信息</strong>，直接 <strong>使用LeakCanary 获取 stack 的方法，使用 leakcanary-analyzer-1.6.2.jar 和 leakcanary-watcher-1.6.2.jar 这两个库文件</strong>。并用 <strong>反射</strong> 的方式调用了 <strong>HeapAnalyzer#findLeakTrace</strong> 方法。</li>
</ul>
<p>其中，<strong>获取堆栈</strong> 的信息也可以直接使用 <strong>haha</strong> 库来进行获取。这里简单说一下 <strong>使用 haha 库获取堆栈的流程</strong>，其具体可以细分为八个步骤，如下所示：</p>
<ul>
<li>1）、首先，<strong>预备一个已经存在重复 bitmap 的 hprof 文件</strong>。</li>
<li>2）、<strong>利用 haha 库上的 MemoryMappedFileBuffer 读取 hrpof 文件 [关键代码 new MemoryMappedFileBuffer(heapDumpFile) ]</strong>。</li>
<li>3）、<strong>解析生成 snapshot，获取 heap，这里我只获取了 app heap [关键代码 snapshot.getHeaps(); heap.getName().equals("app") ]</strong>。</li>
<li>4）、<strong>从 snapshot 中根据指定 class 查找出所有的 Bitmap Classes [关键代码snapshot.findClasses(Bitmap.class.getName()) ]</strong>。</li>
<li>5）、<strong>从 heap 中获得所有的 Bitmap 实例 instance [关键代码 clazz.getHeapInstances(heap.getId()) ]</strong>。</li>
<li>6）、<strong>根据 instance 中获取所有的属性信息 Field[]，并从 Field[] 查找出我们需要的 "mWidth" "mHeight" "mBuffer" 信息</strong>。</li>
<li>7）、<strong>通过 "mBuffer" 属性即可获取到他们的 hashcode 来判断是否是重复图片</strong>。</li>
<li>8）、最后，<strong>通过 instance 中 mNextInstanceToGcRoot 获取整个引用链信息并打印</strong>。</li>
</ul>
<p>在实现图片内存监控的过程中，应注意 <strong>两个关键点</strong>，如下所示：</p>
<ul>
<li>1）、在线上可以按照 <strong>不同的系统、屏幕分辨率</strong> 等纬度去 <strong>分析图片内存的占用情况</strong>。</li>
<li>2）、在 OOM 崩溃时，可以将 <strong>图片总内存、Top N 图片占用内存</strong> 写入 <strong>崩溃日志</strong>。</li>
</ul>
<h3 class="heading" data-id="heading-70">7、建立全局的线上 Bitmap 监控</h3>
<p>为了建立全局的 Bitmap 监控，我们必须 <strong>对 Bitmap 的分配和回收 进行追踪</strong>。我们先来看看 Bitmap 有哪些特点：</p>
<ul>
<li>1）、<strong>创建场景比较单一</strong>：在 Java 层调用 Bitmap.create 或 BitmapFactory 等方法创建，可以封装一层对 Bitmap 创建的接口，注意要 <strong>包含调用第三方库产生的 Bitmap</strong>，这里我们具体可以使用 <strong>编译插桩 + ASM</strong> 的方式来高效地实现。</li>
<li>2）、<strong>创建频率比较低</strong>。</li>
<li>3）、<strong>和 Java 对象的生命周期一样服从 GC，可以使用 WeakReference 来追踪 Bitmap 的销毁</strong>。</li>
</ul>
<p>根据以上特点，我们可以<strong>建立一套 Bitmap 的高性价比监控组件</strong>：</p>
<ul>
<li>1）、首先，在接口层将所有创建出来的 Bitmap 放入一个 WeakHashMap 中，并记录创建 Bitmap 的数据、堆栈等信息。</li>
<li>2）、然后，每隔一定时间查看 WeakHashMap 中有哪些 Bitmap 仍然存活来判断是否出现 Bitmap 滥用或泄漏。</li>
<li>3）、最后，如果发生了 Bitmap 滥用或泄露，则将相关的数据与堆栈等信息打印出来或上报至 APM 后台。</li>
</ul>
<p>这个方案的 <strong>性能消耗很低</strong>，可以在 <strong>正式环境</strong> 中进行。但是，需要注意的一点是，正式与测试环境需要采用不同程度的监控。</p>
<h2 class="heading" data-id="heading-71">3、建立线上应用内存监控体系</h2>
<p>要建立线上应用的内存监控体系，我们需要 <strong>先获取 App 的 DalvikHeap 与 NativeHeap</strong>，它们的获取方式可归结为如下四个步骤：</p>
<ul>
<li>1、首先，<strong>通过 ActivityManager 的 getProcessMemoryInfo =&gt; Debug.MemoryInfo 获取内存信息数据</strong>。</li>
<li>2、然后，通过 <strong>hook Debug.MemoryInfo 的 getMemoryStat 方法（os v23 及以上）可以获得 Memory Profiler 中的多项数据</strong>，进而获得 <strong>细分内存的使用情况</strong>。</li>
<li>3、接着，<strong>通过 Runtime 获取 DalvikHeap</strong>。</li>
<li>4、最后，<strong>通过 Debug.getNativeHeapAllocatedSize 获取 NativeHeap</strong>。</li>
</ul>
<p>对于监控场景，我们需要将其划分为两大类，如下所示：</p>
<ul>
<li>1）、<strong>常规内存监控</strong></li>
<li>2）、<strong>低内存监控</strong></li>
</ul>
<h3 class="heading" data-id="heading-72">1、常规内存监控</h3>
<p><strong>根据 斐波那契数列 每隔一段时间（max：30min）获取内存的使用情况</strong>。常规内存的监控方法有多种实现方式，下面，我们按照 <strong>项目早期 =&gt; 壮大期 =&gt; 成熟期</strong> 的常规内存监控方式进行 <strong>演进式</strong> 讲解。</p>
<h4 class="heading" data-id="heading-73">项目早期：针对场景进行线上 Dump 内存的方式</h4>
<p>具体使用 <strong>Debug.dumpHprofData()</strong> 实现。</p>
<p>其实现的流程为如下四个步骤：</p>
<ul>
<li>1）、<strong>超过最大内存的 80%</strong>。</li>
<li>2）、<strong>内存 Dump</strong>。</li>
<li>3）、<strong>回传文件至服务器</strong>。</li>
<li>4）、<strong>MAT 手动分析</strong>。</li>
</ul>
<p>但是，这种方式有如下几个缺点：</p>
<ul>
<li>1）、<strong>Dump文件太大，和对象数正相关，可以进行裁剪</strong>。</li>
<li>2）、<strong>上传失败率高，分析困难</strong>。</li>
</ul>
<h4 class="heading" data-id="heading-74">壮大期：LeakCanary带到线上的方式</h4>
<p>在使用 LeakCanary 的时候我们需要 <strong>预设泄漏怀疑点，一旦发现泄漏进行回传</strong>。但这种实现方式缺点比较明显，如下所示：</p>
<ul>
<li>1）、<strong>不适合所有情况，需要预设怀疑点</strong>。</li>
<li>2）、<strong>分析比较耗时，容易导致 OOM</strong>。</li>
</ul>
<h4 class="heading" data-id="heading-75">成熟期：定制 LeakCanary 方式</h4>
<h5 class="heading" data-id="heading-76">那么，如何定制线上的LeakCanary？</h5>
<p>定制 LeakCanary 其实就是对 <strong>haha组件</strong> 来进行 <strong>定制</strong>。haha库是 <strong>square</strong> 出品的一款 <strong>自动分析Android堆栈的java库</strong>。这是haha库的 <a href="https://github.com/square/haha" target="_blank" rel="nofollow noopener noreferrer">链接地址</a>。</p>
<p>对于haha库，它的 <strong>基本用法</strong> 一般遵循为如下四个步骤：</p>
<h4 class="heading" data-id="heading-77">1、导出堆栈文件</h4>
<pre><code class="copyable">File heapDumpFile = ...
Debug.dumpHprofData(heapDumpFile.getAbsolutePath());
<span class="copy-code-btn">复制代码</span></code></pre>
<h4 class="heading" data-id="heading-78">2、根据堆栈文件创建出内存映射文件缓冲区</h4>
<pre><code class="copyable">DataBuffer buffer = new MemoryMappedFileBuffer(heapDumpFile);
<span class="copy-code-btn">复制代码</span></code></pre>
<h4 class="heading" data-id="heading-79">3、根据文件缓存区创建出对应的快照</h4>
<pre><code class="copyable">Snapshot snapshot = Snapshot.createSnapshot(buffer);
<span class="copy-code-btn">复制代码</span></code></pre>
<h4 class="heading" data-id="heading-80">4、从快照中获取指定的类</h4>
<pre><code class="copyable">ClassObj someClass = snapshot.findClass("com.example.SomeClass");
<span class="copy-code-btn">复制代码</span></code></pre>
<p>我们在实现线上版的LeakCanary的时候主要要解决的问题有三个，如下所示：</p>
<ul>
<li>1）、<strong>解决 预设怀疑点 时不准确的问题 =&gt; 自动找怀疑点</strong>。</li>
<li>2）、<strong>解决掉将 hprof 文件映射到内存中的时候可能导致内存暴涨甚至发生 OOM 的问题 =&gt; 对象裁剪，不全部加载到内存。即对生成的 Hprof 内存快照文件做一些优化：裁剪大部分图片对应的 byte 数据 以减少文件开销，最后，使用 7zip 压缩，一般可 节省 90% 大小</strong>。</li>
<li>3）、<strong>分析泄漏链路慢而导致分析时间过长 =&gt; 分析 Retain size 大的对象</strong>。</li>
</ul>
<h4 class="heading" data-id="heading-81">成熟期：实现内存泄漏监控闭环</h4>
<p>在实现了线上版的 LeakCanary 之后，就需要 <strong>将线上版的 LeakCanary 与服务器和前端页面结合</strong> 起来。具体的 <strong>内存泄漏监控闭环流程</strong> 如下所示：</p>
<ul>
<li>1）、<strong>当在线上版 LeakCanary 上发现内存泄漏时，手机将上传内存快照至服务器</strong>。</li>
<li>2）、<strong>此时服务器分析 Hprof，如果不是系统原因导致误报则通过 git 得到该最近修改人</strong>。</li>
<li>3）、<strong>最后将内存泄漏 bug 单提交给负责人。该负责人通过前端实现的 bug 单系统即可看到自己新增的bug</strong>。</li>
</ul>
<h3 class="heading" data-id="heading-82">2、低内存监控</h3>
<p>对于低内存的监控，通常有两种方式，分别如下所示：</p>
<ul>
<li>1、<strong>利用 onTrimMemory / onLowMemory 监听系统回调的物理内存警告</strong>。</li>
<li>2、<strong>在后台起一个服务定时监控系统的内存占用，只要超过虚拟内存大小最大限制的 90% 则直接触发内存警告</strong>。</li>
</ul>
<h3 class="heading" data-id="heading-83">3、内存监控指标</h3>
<p>为了准确衡量内存性能，我们需要引入一系列的内存监控指标，如下所示：</p>
<h4 class="heading" data-id="heading-84">1）、发生频率</h4>
<h4 class="heading" data-id="heading-85">2）、发生时各项内存使用状况</h4>
<h4 class="heading" data-id="heading-86">3）、发生时App的当前场景</h4>
<h4 class="heading" data-id="heading-87">4）、内存异常率</h4>
<pre><code class="copyable">内存 UV 异常率 = PSS 超过 400MB 的 UV / 采集UV
PSS 获取：调用 Debug.MemoryInfo 的 API 即可
<span class="copy-code-btn">复制代码</span></code></pre>
<p>如果出现 <strong>新的内存使用不当或内存泄漏</strong> 的场景，这个指标会有所 <strong>上涨</strong>。</p>
<h4 class="heading" data-id="heading-88">5）、触顶率</h4>
<pre><code class="copyable">内存 UV 触顶率 = Java 堆占用超过最大堆限制的 85% 的 UV / 采集UV
<span class="copy-code-btn">复制代码</span></code></pre>
<p>计算触顶率的代码如下所示：</p>
<pre><code class="copyable">long javaMax = Runtime.maxMemory();
long javaTotal = Runtime.totalMemory();
long javaUsed = javaTotal - runtime.freeMemory();
float proportion = (float) javaUsed / javaMax;
<span class="copy-code-btn">复制代码</span></code></pre>
<p>如果超过 <strong>85% 最大堆</strong> 的限制，<strong>GC</strong> 会变得更加 <strong>频发</strong>，容易造成 <strong>OOM 和 卡顿</strong>。</p>
<h3 class="heading" data-id="heading-89">4、小结</h3>
<p>在具体实现的时候，<strong>客户端</strong> 尽量只负责 <strong>上报数据</strong>，而 <strong>指标值的计算</strong> 可以由 <strong>后台</strong> 来计算。这样便可以通过 <strong>版本对比</strong> 来<strong>监控</strong>是否有 <strong>新增内存问题</strong>。因此，<strong>建立线上内存监控的完整方案</strong> 至少需要包含以下<strong>四点</strong>：</p>
<ul>
<li>1）、<strong>待机内存、重点模块内存、OOM率</strong>。</li>
<li>2）、<strong>整体及重点模块 GC 次数、GC 时间</strong>。</li>
<li>3）、<strong>增强的 LeakCanry 自动化内存泄漏分析</strong>。</li>
<li>4）、<strong>低内存监控模块的设置</strong>。</li>
</ul>
<h2 class="heading" data-id="heading-90">4、建立全局的线程监控组件</h2>
<p><strong>每个线程初始化都需要 mmap 一定的栈大小，在默认情况下初始化一个线程需要 mmap 1MB 左右的内存空间</strong>。</p>
<p>在 <strong>32bit</strong> 的应用中有 <strong>4g 的 vmsize</strong>，<strong>实际</strong>能使用的有 <strong>3g+</strong>，这样一个进程 <strong>最大能创建的线程数</strong> 可以达到 <strong>3000个</strong>，但是，<strong>linux 对每个进程可创建的线程数也有一定的限制（/proc/pid/limits）</strong>，并且，<strong>不同厂商也能修改这个限制</strong>，超过该限制就会 OOM。</p>
<p>因此，对线程数量的限制，在一定程度上可以 <strong>有效地避免 OOM 的发生</strong>。那么，实现一套 <strong>全局的线程监控组件</strong> 便是 <strong>刻不容缓</strong> 的了。</p>
<h3 class="heading" data-id="heading-91">全局线程监控组件的实现原理</h3>
<p><strong>在线下或灰度的环境下通过一个定时器每隔 10分钟 dump 出应用所有的线程相关信息，当线程数超过当前阈值时，则将当前的线程信息上报并预警</strong>。</p>
<h2 class="heading" data-id="heading-92">5、GC 监控组件搭建</h2>
<p>通过** Debug.startAllocCounting** 来监控 <strong>GC</strong> 情况，注意有一定 <strong>性能影响</strong>。</p>
<p>在 <strong>Android 6.0 之前</strong> 可以拿到 <strong>内存分配次数和大小以及 GC 次数</strong>，其对应的代码如下所示：</p>
<pre><code class="copyable">long allocCount = Debug.getGlobalAllocCount();
long allocSize = Debug.getGlobalAllocSize();
long gcCount = Debug.getGlobalGcInvocationCount();
<span class="copy-code-btn">复制代码</span></code></pre>
<p>并且，在 <strong>Android 6.0 及之后</strong> 可以拿到 <strong>更精准</strong> 的 <strong>GC</strong> 信息：</p>
<pre><code class="copyable">Debug.getRuntimeStat("art.gc.gc-count");
Debug.getRuntimeStat("art.gc.gc-time");
Debug.getRuntimeStat("art.gc.blocking-gc-count");
Debug.getRuntimeStat("art.gc.blocking-gc-time");
<span class="copy-code-btn">复制代码</span></code></pre>
<p>对于 <strong>GC 信息的排查</strong>，我们一般关注 <strong>阻塞式GC的次数和耗时</strong>，因为它会 <strong>暂停线程</strong>，可能导致应用发生 <strong>卡顿</strong>。建议 <strong>仅对重度场景使用</strong>。</p>
<h2 class="heading" data-id="heading-93">6、建立线上 OOM 监控组件：Probe</h2>
<p>美团的 Android <strong>内存泄漏自动化链路分析组件</strong> <strong>Probe</strong> 在 <strong>OOM</strong> 时会生成 <strong>Hprof 内存快照</strong>，然后，它会通过 <strong>单独进程</strong> 对这个 <strong>文件</strong> 做进一步 <strong>分析</strong>。</p>
<h3 class="heading" data-id="heading-94">Probe 组件的缺陷及解决方案</h3>
<p>它的缺点比较多，具体为如下几点：</p>
<ul>
<li>1、<strong>在崩溃的时候生成内存快照容易导致二次崩溃</strong>。</li>
<li>2、<strong>部分手机生成 Hprof 快照比较耗时</strong>。</li>
<li>3、<strong>部分 OOM 是由虚拟内存不足导致</strong>。</li>
</ul>
<p>在实现自动化链路分析组件 Probe 的过程中主要要解决两个问题，如下所示：</p>
<h4 class="heading" data-id="heading-95">1、链路分析时间过长</h4>
<ul>
<li>1）、使用<strong>链路归并</strong>：将具有 <strong>相同层级与结构</strong> 的链路进行 <strong>合并</strong>。</li>
<li>2）、使用 <strong>自适应扩容法</strong>：<strong>通过不断比较现有链路和新链路，结合扩容因子，逐渐完善为完整的泄漏链路</strong>。</li>
</ul>
<h4 class="heading" data-id="heading-96">2、分析进程占用内存过大</h4>
<p><strong>分析进程占用的内存</strong> 跟 <strong>内存快照文件的大小</strong> 不成正相关，而跟 <strong>内存快照文件的 Instance 数量</strong> 呈 <strong>正相关</strong>。所以在开发过程中我们应该 <strong>尽可能排除不需要的Instance实例</strong>。</p>
<h3 class="heading" data-id="heading-97">Prope 分析流程揭秘</h3>
<p>Prope 的 <strong>总体架构图</strong> 如下所示：</p>
<figure><img class="lazyload" src="./干货集中营_files/bc1c8e5918454c2f89812b179ab7ae4a" alt="image" data-height="775" data-width="1280">
<figcaption></figcaption>
</figure>
<p>而它的整个分析流程具体可以细分为八个步骤，如下所示：</p>
<h4 class="heading" data-id="heading-98">1、hprof 映射到内存 =&gt; 解析成 Snapshot &amp; 计数压缩：</h4>
<p>解析后的 Snapshot 中的 Heap 有四种类型，具体为：</p>
<ul>
<li>1）、<strong>DefaultHeap</strong></li>
<li>2）、<strong>ImageHeap</strong></li>
<li>3）、<strong>App Heap</strong>：包括 <strong>ClassInstance、ClassObj、ArrayInstance、RootObj</strong>。</li>
<li>4）、<strong>System Heap</strong></li>
</ul>
<p><strong>解析完</strong> 后使用了 <strong>计数压缩策略</strong>，对 <strong>相同的 Instance</strong> 使用 <strong>计数</strong>，以 <strong>减少占用内存。超过计数阈值的需要计入计数桶（计数桶记录了 丢弃个数 和 每个 Instance 的大小）</strong>。</p>
<h4 class="heading" data-id="heading-99">2、<strong>生成 Dominator Tree</strong>。</h4>
<h4 class="heading" data-id="heading-100">3、<strong>计算 RetainSize</strong>。</h4>
<h4 class="heading" data-id="heading-101">4、<strong>生成 Reference 链 &amp;&amp; 基础数据类型增强</strong>:</h4>
<p>如果对象是 <strong>基础数据类型</strong>，会将 <strong>自身的 RetainSize 累加到父节点</strong> 上，将 <strong>怀疑对象</strong> 替换为它的 <strong>父节点</strong>。</p>
<h4 class="heading" data-id="heading-102">5、<strong>链路归并</strong>。</h4>
<h4 class="heading" data-id="heading-103">6、<strong>计数桶补偿 &amp; 基础数据类型和父节点融合</strong>：</h4>
<p><strong>使用计数补偿策略计算 RetainSize，主要是 判断对象是否在计数桶中，如果在的话则将 丢弃的个数和大小补偿到对象上，累积计算RetainSize，最后对 RetainSize 排序以查找可疑对象</strong>。</p>
<h4 class="heading" data-id="heading-104">7、<strong>排序扩容</strong>。</h4>
<h4 class="heading" data-id="heading-105">8、<strong>查找泄露链路</strong>。</h4>
<h2 class="heading" data-id="heading-106">7、实现 单机版 的 Profile Memory 自动化内存分析</h2>
<p><a href="https://github.com/JsonChao/Chapter03" target="_blank" rel="nofollow noopener noreferrer">项目地址请点击此处</a></p>
<p>在配置的时候要注意两个问题：</p>
<ul>
<li>
<p>1、<strong>liballoc-lib.so在构建后工程的 build =&gt; intermediates =&gt; cmake 目录下。将对应的 cpu abi 目录拷贝到新建的 libs 目录下</strong>。</p>
</li>
<li>
<p>2、<strong>在 DumpPrinter Java 库的 build.gradle 中的 jar 闭包中需要加入以下代码以识别源码路径:</strong></p>
<p>sourceSets.main.java.srcDirs = ['src']</p>
</li>
</ul>
<h3 class="heading" data-id="heading-107">使用步骤</h3>
<p>具体的使用步骤如下所示：</p>
<h4 class="heading" data-id="heading-108">1、首先，点击 ”开始记录“ 按钮可以看到触发对象分配的记录，说明对象已经开始记录对象的分配，log如下所示：</h4>
<pre><code class="copyable">12-26 10:54:03.963 30450-30450/com.dodola.alloctrack I/AllocTracker: ====current alloc count 388=====
<span class="copy-code-btn">复制代码</span></code></pre>
<h4 class="heading" data-id="heading-109">2、然后，点击多次 ”生成1000个对象“ 按钮，当对象达到设置的最大数量的时候触发内存dump，会得到保存数据路径的日志。如下所示：</h4>
<pre><code class="copyable">12-26 10:54:03.963 30450-30450/com.dodola.alloctrack I/AllocTracker: ====current alloc count 388=====
12-26 10:56:45.103 30450-30450/com.dodola.alloctrack I/AllocTracker: saveARTAllocationData write file to /storage/emulated/0/crashDump/1577329005
<span class="copy-code-btn">复制代码</span></code></pre>
<h4 class="heading" data-id="heading-110">3、此时，可以看到数据保存在 sdk 下的 crashDump 目录下。</h4>
<h4 class="heading" data-id="heading-111">4、接着，通过 gradle task :buildAlloctracker 任务编译出存放在 tools/DumpPrinter-1.0.jar 的 dump 工具，然后采用如下命令来将数据解析 到dump_log.txt 文件中。</h4>
<pre><code class="copyable">java -jar tools/DumpPrinter-1.0.jar dump文件路径 &gt; dump_log.txt
<span class="copy-code-btn">复制代码</span></code></pre>
<h4 class="heading" data-id="heading-112">5、最后，就可以在 dump_log.txt 文件中看到解析出来的数据，如下所示：</h4>
<pre><code class="copyable">Found 4949 records:
tid=1 byte[] (94208 bytes)
    dalvik.system.VMRuntime.newNonMovableArray (Native method)
    android.graphics.Bitmap.nativeCreate (Native method)
    android.graphics.Bitmap.createBitmap (Bitmap.java:975)
    android.graphics.Bitmap.createBitmap (Bitmap.java:946)
    android.graphics.Bitmap.createBitmap (Bitmap.java:913)
    android.graphics.drawable.RippleDrawable.updateMaskShaderIfNeeded (RippleDrawable.java:776)
    android.graphics.drawable.RippleDrawable.drawBackgroundAndRipples (RippleDrawable.java:860)
    android.graphics.drawable.RippleDrawable.draw (RippleDrawable.java:700)
    android.view.View.getDrawableRenderNode (View.java:17736)
    android.view.View.drawBackground (View.java:17660)
    android.view.View.draw (View.java:17467)
    android.view.View.updateDisplayListIfDirty (View.java:16469)
    android.view.ViewGroup.recreateChildDisplayList (ViewGroup.java:3905)
    android.view.ViewGroup.dispatchGetDisplayList (ViewGroup.java:3885)
    android.view.View.updateDisplayListIfDirty (View.java:16429)
    android.view.ViewGroup.recreateChildDisplayList (ViewGroup.java:3905)
<span class="copy-code-btn">复制代码</span></code></pre>
<h2 class="heading" data-id="heading-113">8、搭建线下 Native 内存泄漏监控体系</h2>
<p>在 <strong>Android 8.0 及之后</strong>，可以使用 <strong>Address Sanitizer、Malloc 调试和 Malloc 钩子</strong> 进行 <strong>native 内存分析</strong>，参见 <a href="https://source.android.com/devices/tech/debug/native-memory" target="_blank" rel="nofollow noopener noreferrer">native_memory</a></p>
<p>对于线下 Native 内存泄漏监控的建立，主要针对 <strong>是否能重编 so 的情况</strong> 来记录分配的内存信息。</p>
<h3 class="heading" data-id="heading-114">针对无法重编so的情况</h3>
<ul>
<li>1）、首先，使用 <strong>PLT Hook 拦截库的内存分配函数</strong>，然后，重定向到我们自己的实现后去 <strong>记录分配的 内存地址、大小、来源so库路径</strong> 等信息。</li>
<li>2）、最后，<strong>定期 扫描分配与释放 的配对内存块，对于 不配对的分配 输出上述记录的信息</strong>。</li>
</ul>
<h3 class="heading" data-id="heading-115">针对可重编的so情况</h3>
<ul>
<li>1）、首先，通过 <strong>GCC</strong> 的 <strong>”-finstrument-functions“</strong> 参数给 <strong>所有函数插桩</strong>，然后，<strong>在桩中模拟调用栈的入栈与出栈操作</strong>。</li>
<li>2）、接着，通过 <strong>ld</strong> 的 <strong>”--warp“</strong> 参数 <strong>拦截内存分配和释放函数</strong>，重定向到我们自己的实现后<strong>记录分配的 内存地址、大小、来源so以及插桩调用栈此刻的内容</strong>。</li>
<li>3）、最后，<strong>定期扫描分配与释放是否配对，对于不配对的分配输出我们记录的信息</strong>。</li>
</ul>
<h2 class="heading" data-id="heading-116">9、设置内存兜底策略</h2>
<p>设置内存兜底策略的目的，是为了 <strong>在用户无感知的情况下，在接近触发系统异常前，选择合适的场景杀死进程并将其重启，从而使得应用内存占用回到正常情况</strong>。</p>
<p>通常执行内存兜底策略时至少需要满足六个条件，如下所示：</p>
<ul>
<li>1）、<strong>是否在主界面退到后台且位于后台时间超过 30min</strong>。</li>
<li>2）、<strong>当前时间为早上 2~5 点</strong>。</li>
<li>3）、<strong>不存在前台服务（通知栏、音乐播放栏等情况）</strong>。</li>
<li>4）、<strong>Java heap 必须大于当前进程最大可分配的85% || native内存大于800MB</strong>。</li>
<li>5）、<strong>vmsize 超过了4G（32bit）的85%</strong>。</li>
<li>6）、<strong>非大量的流量消耗（不超过1M/min） &amp;&amp; 进程无大量CPU调度情况</strong>。</li>
</ul>
<p>只有在满足了以上条件之后，我们才会去<strong>杀死当前主进程并通过 push 进程重新拉起及初始化</strong>。</p>
<h2 class="heading" data-id="heading-117">10、更深入的内存优化策略</h2>
<p>除了在 <a href="https://juejin.im/post/5e72b2d151882549236f9cb8#heading-52" target="_blank" rel="noopener">Android性能优化之内存优化 =&gt; 优化内存空间</a> 中讲解过的一些常规的内存优化策略以外，在下面列举了一些更深入的内存优化策略。</p>
<h3 class="heading" data-id="heading-118">1、使 bitmap 资源在 native 中分配</h3>
<p><strong>对于 Android 2.x 系统，使用反射将 BitmapFactory.Options 里面隐藏的 inNativeAlloc 打开</strong>。</p>
<p><strong>对于 Android 4.x 系统，使用或借鉴 Fresco 将 bitmap 资源在 native 中分配的方式</strong>。</p>
<h3 class="heading" data-id="heading-119">2、图片加载时的降级处理</h3>
<p>使用 Glide、Fresco 等图片加载库，通过定制，在加载 bitmap 时，若发生 OOM，则使用 try catch 将其捕获，然后清除图片 cache，尝试降低 bitmap format（ARGB8888、RGB565、ARGB4444、ALPHA8）。</p>
<p>需要注意的是，OOM 是可以捕获的，只要 OOM 是由 try 语句中的对象声明所导致的，那么在 catch 语句中，是可以释放掉这些对象，解决 OOM 的问题的。</p>
<h3 class="heading" data-id="heading-120">3、前台每隔 3 分钟去获取当前应用内存占最大内存的比例，超过设定的危险阈值（如80%）则主动释放应用 cache（Bitmap 为大头），并且显示地除去应用的 memory，以加速内存收集的过程。</h3>
<p>计算当前应用内存占最大内存的比例的代码如下：</p>
<pre><code class="copyable">max = Runtime.getRuntime().maxMemory();
available = Runtime.getRuntime.totalMemory() - Runtime.getFreeMemory();
ratio = available / max;
<span class="copy-code-btn">复制代码</span></code></pre>
<p>显示地除去应用的 memory，以加速内存收集过程的代码如下所示：</p>
<pre><code class="copyable">WindowManagerGlobal.getInstance().startTrimMemory(TRIM_MEMORY_COMPLETE);
<span class="copy-code-btn">复制代码</span></code></pre>
<h3 class="heading" data-id="heading-121">5、由于 webview 存在内存系统泄漏，还有 图库占用内存过多 的问题，可以采用单独的进程。</h3>
<h3 class="heading" data-id="heading-122">6、当UI隐藏时释放内存</h3>
<p>当用户切换到其它应用并且你的应用 UI 不再可见时，应该释放应用 UI 所占用的所有内存资源。这能够显著增加系统缓存进程的能力，能够提升用户体验。</p>
<p><strong>在所有 UI 组件都隐藏的时候会接收到 Activity 的 onTrimMemory() 回调并带有参数 TRIM_MEMORY_UI_HIDDEN</strong>。</p>
<h3 class="heading" data-id="heading-123">7、Activity 的兜底内存回收策略</h3>
<p>在 Activity 的 onDestory 中递归释放其引用到的 Bitmap、DrawingCache 等资源，以降低发生内存泄漏时对应用内存的压力。</p>
<h3 class="heading" data-id="heading-124">8、使用类似 Hack 的方式修复系统内存泄漏</h3>
<p>LeakCanary 的 AndroidExcludeRefs 列出了一些由于系统原因导致引用无法释放的例子，可使用类似 Hack 的方式去修复。具体的实现代码可以参考 <a href="https://github.com/didi/booster#what-can-booster-be-used-for--booster-%E8%83%BD%E5%81%9A%E4%BB%80%E4%B9%88" target="_blank" rel="nofollow noopener noreferrer">Booster =&gt; 系统问题修复</a>。</p>
<h3 class="heading" data-id="heading-125">9、应用发生 OOM 时，需要上传更加详细的内存相关信息。</h3>
<h3 class="heading" data-id="heading-126">10、当应用使用的Service不再使用时应该销毁它，建议使用 IntentServcie。</h3>
<h3 class="heading" data-id="heading-127">11、谨慎使用第三方库，避免为了使用其中一两个功能而导入一个大而全的解决方案。</h3>
<h1 class="heading" data-id="heading-128">六、内存优化演进</h1>
<h2 class="heading" data-id="heading-129">1、自动化测试阶段</h2>
<p>内存达到阈值后自动触发 Hprof Dump，将得到的 Hprof 存档后由人工通过 MAT 进行分析。</p>
<h2 class="heading" data-id="heading-130">2、LeakCanary</h2>
<p>检测和分析报告都在一起，批量自动化测试和事后分析都不太方便。</p>
<h2 class="heading" data-id="heading-131">3、使用基于 LeakCannary 的改进版 ResourceCanary</h2>
<p><a href="https://github.com/Tencent/matrix/wiki/Matrix-Android-ResourceCanary#matrix-resourcecanary" target="_blank" rel="nofollow noopener noreferrer">Matrix =&gt; ResourceCanary 实现原理</a></p>
<h3 class="heading" data-id="heading-132">主要功能</h3>
<p>目前，它的主要功能有 <strong>三个部分</strong>，如下所示：</p>
<h4 class="heading" data-id="heading-133">1、分离 检测和分析 两部分流程</h4>
<p>自动化测试由测试平台进行，分析则由监控平台的服务端离线完成，最后再通知相关开发解决问题。</p>
<h4 class="heading" data-id="heading-134">2、裁剪 Hprof文件，以降低 传输 Hprof 文件与后台存储 Hprof 文件的开销</h4>
<p>获取 <strong>需要的类和对象相关的字符串</strong> 信息即可，其它数据都可以<strong>在客户端裁剪</strong>，一般能 Hprof 大小会<strong>减小</strong>至原来的 <strong>1/10</strong> 左右。</p>
<h4 class="heading" data-id="heading-135">3、增加重复 Bitmap 对象检测</h4>
<p>方便通过减少冗余 Bitmap 的数量，以降低内存消耗。</p>
<h3 class="heading" data-id="heading-136">4、小结</h3>
<p>在研发阶段需要不断实现 <strong>更多的工具和组件</strong>，以此系统化地<strong>提升自动化程度</strong>，以最终 <strong>提升发现问题的效率</strong>。</p>
<h1 class="heading" data-id="heading-137">七、内存优化工具</h1>
<p>除了常用的内存分析工具 Memory Profiler、MAT、LeakCanary 之外，还有一些其它的内存分析工具，下面我将一一为大家进行介绍。</p>
<h2 class="heading" data-id="heading-138">1、top</h2>
<p>top 命令是 Linux 下常用的性能分析工具，能够 <strong>实时显示系统中各个进程的资源占用状况</strong>，类似于 <strong>Windows 的任务管理器</strong>。top 命令提供了 实时的对系统处理器的状态监视。它将 <strong>显示系统中 CPU 最“敏感”的任务列表</strong>。该命令可以按 <strong>CPU使用、内存使用和执行时间 对任务进行排序</strong>。</p>
<p>接下来，我们输入以下命令查看top命令的用法：</p>
<pre><code class="copyable">quchao@quchaodeMacBook-Pro ~ % adb shell top --help
usage: top [-Hbq] [-k FIELD,] [-o FIELD,] [-s SORT] [-n NUMBER] [-d SECONDS] [-p PID,] [-u USER,]

Show process activity in real time.

-H	Show threads
-k	Fallback sort FIELDS (default -S,-%CPU,-ETIME,-PID)
-o	Show FIELDS (def PID,USER,PR,NI,VIRT,RES,SHR,S,%CPU,%MEM,TIME+,CMDLINE)
-O	Add FIELDS (replacing PR,NI,VIRT,RES,SHR,S from default)
-s	Sort by field number (1-X, default 9)
-b	Batch mode (no tty)
-d	Delay SECONDS between each cycle (default 3)
-n	Exit after NUMBER iterations
-p	Show these PIDs
-u	Show these USERs
-q	Quiet (no header lines)

Cursor LEFT/RIGHT to change sort, UP/DOWN move list, space to force
update, R to reverse sort, Q to exit.
<span class="copy-code-btn">复制代码</span></code></pre>
<p>这里使用 top 仅显示一次进程信息，以便来讲解进程信息中各字段的含义。</p>
<figure><img class="lazyload" src="./干货集中营_files/109e42850ad74cf2b3119b3b09e94c85" alt="image" data-height="968" data-width="1280">
<figcaption></figcaption>
</figure>
<h3 class="heading" data-id="heading-139">整体的统计信息区</h3>
<p><strong>前四行</strong> 是当前系统情况 <strong>整体的统计信息区</strong>。下面我们看每一行信息的具体意义。</p>
<h4 class="heading" data-id="heading-140">第一行：Tasks — 任务（进程）</h4>
<p>具体信息说明如下所示：</p>
<p>系统现在共有 729 个进程，其中处于 <strong>运行中</strong> 的有 1 个，715 个在 <strong>休眠（sleep）</strong>，<strong>stoped</strong> 状态的有0个，<strong>zombie</strong> 状态（僵尸）的有 8 个。</p>
<h4 class="heading" data-id="heading-141">第二行：内存状态</h4>
<p>具体信息如下所示：</p>
<ul>
<li>1）、<strong>5847124k total：物理内存总量（5.8GB）</strong></li>
<li>2）、<strong>5758016k used：使用中的内存总量（5.7GB）</strong></li>
<li>3）、<strong>89108k free：空闲内存总量（89MB）</strong></li>
<li>4）、<strong>112428k buffers：缓存的内存量 （112M）</strong></li>
</ul>
<h4 class="heading" data-id="heading-142">第三行：swap交换分区信息</h4>
<p>具体信息说明如下所示：</p>
<ul>
<li>1）、<strong>2621436k total：交换区总量（2.6GB）</strong></li>
<li>2）、<strong>612572k used：使用的交换区总量（612MB）</strong></li>
<li>3）、<strong>2008864k free：空闲交换区总量（2GB）</strong></li>
<li>4）、<strong>2657696k cached：缓冲的交换区总量（2.6GB）</strong></li>
</ul>
<h4 class="heading" data-id="heading-143">第四行：cpu状态信息</h4>
<p>具体属性说明如下所示：</p>
<ul>
<li>1）、<strong>800% cpu：8核 CPU</strong></li>
<li>2）、<strong>39% user：39% CPU被用户进程使用</strong></li>
<li>3）、<strong>0% nice：优先值为负的进程占 0%</strong></li>
<li>4）、<strong>42% sys — 内核空间占用 CPU 的百分比为 42%</strong></li>
<li>5）、<strong>712% idle：除 IO 等待时间以外的其它等待时间为 712%</strong></li>
<li>6）、<strong>0% iow：IO 等待时间占 0%</strong></li>
<li>7）、<strong>0% irq：硬中断时间占 0%</strong></li>
<li>8）、<strong>6% sirq - 软中断时间占 0%</strong></li>
</ul>
<p>对于内存监控，在 top 里我们要时刻监控 <strong>第三行 swap 交换分区的 used</strong>，如果这个数值在不断的<strong>变化</strong>，说明内核在不断<strong>进行内存和 swap 的数据交换</strong>，这是真正的内存不够用了。</p>
<h3 class="heading" data-id="heading-144">进程（任务）的状态监控</h3>
<p>在 <strong>第五行及以下</strong>，就是各进程（任务）的状态监控，项目列信息说明如下所示：</p>
<ul>
<li>1）、<strong>PID：进程 id</strong></li>
<li>2）、<strong>USER：进程所有者</strong></li>
<li>3）、<strong>PR：进程优先级</strong></li>
<li>4）、<strong>NI：nice 值。负值表示高优先级，正值表示低优先级</strong></li>
<li>5）、<strong>VIRT：进程使用的虚拟内存总量。VIRT = SWAP + RES</strong></li>
<li>6）、<strong>RES：进程使用的、未被换出的物理内存大小。RES = CODE + DATA</strong></li>
<li>7）、<strong>SHR：共享内存大小</strong></li>
<li>8)、<strong>S：进程状态。D = 不可中断的睡眠状态、R = 运行、 S = 睡眠、T = 跟踪 / 停止、Z = 僵尸进程</strong></li>
<li>9）、<strong>%CPU — 上次更新到现在的 CPU 时间占用百分比</strong></li>
<li>10）、<strong>%MEM：进程使用的物理内存百分比</strong></li>
<li>11）、<strong>TIME+：进程使用的 CPU 时间总计，单位 1/100秒</strong></li>
<li>12）、<strong>ARGS：进程名称（命令名 / 命令行）</strong></li>
</ul>
<p>从上图中可以看到，第一行的就是 <a href="https://github.com/JsonChao/Awesome-WanAndroid" target="_blank" rel="nofollow noopener noreferrer">Awesome-WanAndroid</a> 这个应用的进程，它的进程名称为 json.chao.com.w+，PID 为 23104，进程所有者 USER 为 u0_a714，进程优先级 PR 为 10，nice 置 NI 为 -10。进程使用的虚拟内存总量 VIRT 为 4.3GB，进程使用的、未被换出的物理内存大小 RES 为138M，共享内存大小 SHR 为 66M，进程状态 S 是睡眠状态，上次更新到现在的 CPU 时间占用百分比 %CPU 为 21.2。进程使用的物理内存百分比 %MEM 为 2.4%，进程使用的 CPU 时间 TIME+ 为 1:47.58 / 100小时。</p>
<h2 class="heading" data-id="heading-145">2、dumpsys meminfo</h2>
<h3 class="heading" data-id="heading-146">四大内存指标</h3>
<p>在讲解 dumpsys meminfo 命令之前，我们必须先了解下 Android 中最重要的 <strong>四大内存指标</strong> 的概念，如下表所示：</p>
<table>
<thead>
<tr>
<th>内存指标</th>
<th>英文全称</th>
<th>含义</th>
<th>等价</th>
</tr>
</thead>
<tbody>
<tr>
<td>USS</td>
<td>Unique Set Size</td>
<td>物理内存</td>
<td>进程独占的内存</td>
</tr>
<tr>
<td>PSS</td>
<td>Proportional Set Size</td>
<td>物理内存</td>
<td>PSS = USS + 按比例包含共享库</td>
</tr>
<tr>
<td>RSS</td>
<td>Resident Set Size</td>
<td>物理内存</td>
<td>RSS= USS+ 包含共享库</td>
</tr>
<tr>
<td>VSS</td>
<td>Virtual Set Size</td>
<td>虚拟内存</td>
<td>VSS= RSS+ 未分配实际物理内存</td>
</tr>
</tbody>
</table>
<p>从上可知，它们之间内存的大小关系为 <strong>VSS &gt;= RSS &gt;= PSS &gt;= USS</strong>。</p>
<p>RSS 与 PSS 相似，也包含进程共享内存，但比较麻烦的是 <strong>RSS 并没有把共享内存大小全都平分到使用共享的进程头上，以至于所有进程的 RSS 相加会超过物理内存很多</strong>。而 <strong>VSS</strong> 是虚拟地址，它的<strong>上限与进程的可访问地址空间有关，和当前进程的内存使用关系并不大</strong>。比如有很多的 map 内存也被算在其中，我们都知道，file 的 map 内存对应的可能是一个文件或硬盘，或者某个奇怪的设备，它与进程使用内存并没有多少关系。</p>
<p>而 <strong>PSS、USS 最大的不同在于 “共享内存“（比如两个 App 使用 MMAP 方式打开同一个文件，那么打开文件而使用的这部分内存就是共享的），USS不包含进程间共享的内存，而PSS包含</strong>。这也造成了USS因为缺少共享内存，所有进程的USS相加要小于物理内存大小的原因。</p>
<p>最早的时候官方就推荐使用 PSS 曲线图来衡量 App 的物理内存占用，而 Android 4.4 之后才加入 USS。但是 <strong>PSS</strong>，有个很大的<strong>问题</strong>，就是 <strong>”共享内存“</strong>，考虑一种情况，<strong>如果 A 进程与 B 进程都会使用一个共享 SO 库，那么 So 库中初始化所用掉的那部分内存就会平分到 A 与 B 的头上。但是 A 是在 B 之后启动的，那么对于 B 的 PSS 曲线而言，在 A 启动的那一刻，即使 B 没有做任何事情，也会出现一个比较大的阶梯状下滑，这会给用曲线图分析软件内存的行为造成致命的麻烦</strong>。</p>
<p>USS 虽然没有这个问题，但是由于 <strong>Dalvik 虚拟机申请内存牵扯到 GC 时延和多种 GC 策略</strong>，这些都会<strong>影响到曲线的异常波动</strong>。例如<strong>异步 GC</strong> 是 Android 4.0 以上系统很重要的特性，但是 GC <strong>什么时候结束？曲线什么时候”降低“</strong>？就 <strong>无法预计</strong> 了。还有 <strong>GC 策略</strong>，什么时候开始增加 Dalvik 虚拟机的预申请内存大小（Dalvik 启动时是有一个标称的 start 内存大小，它是为 Java 代码运行时预留的，避免 Java 运行时再申请而造成卡顿），但是这个 <strong>预申请大小是动态变化的</strong>，这一点也会 <strong>造成 USS 忽大忽小</strong>。</p>
<h3 class="heading" data-id="heading-147">dumpsys meminfo 命令解析</h3>
<p>了解完 Android 内存的性能指标之后，下面我们便来说说 dumpsys meminfo 这个命令的用法，首先我们输入 adb shell dumpsys meminfo -h 查看它的帮助文档：</p>
<pre><code class="copyable">quchao@quchaodeMacBook-Pro ~ % adb shell dumpsys meminfo -h
meminfo dump options: [-a] [-d] [-c] [-s] [--oom] [process]
-a: include all available information for each process.
-d: include dalvik details.
-c: dump in a compact machine-parseable representation.
-s: dump only summary of application memory usage.
-S: dump also SwapPss.
--oom: only show processes organized by oom adj.
--local: only collect details locally, don't call process.
--package: interpret process arg as package, dumping all
            processes that have loaded that package.
--checkin: dump data for a checkin
If [process] is specified it can be the name or
pid of a specific process to dump.
<span class="copy-code-btn">复制代码</span></code></pre>
<p>接着，我们之间输入adb shell dumpsys meminfo命令：</p>
<pre><code class="copyable">quchao@quchaodeMacBook-Pro ~ % adb shell dumpsys meminfo
Applications Memory Usage (in Kilobytes):
Uptime: 257501238 Realtime: 257501238

// 根据进程PSS占用值从大到小排序
Total PSS by process:
    308,049K: com.tencent.mm (pid 3760 / activities)
    225,081K: system (pid 2088)
    189,038K: com.android.systemui (pid 2297 / activities)
    188,877K: com.miui.home (pid 2672 / activities)
    176,665K: com.plan.kot32.tomatotime (pid 22744 / activities)
    175,231K: json.chao.com.wanandroid (pid 23104 / activities)
    126,918K: com.tencent.mobileqq (pid 23741)
    ...

// 以oom来划分，会详细列举所有的类别的进程
Total PSS by OOM adjustment:
    432,013K: Native
        76,700K: surfaceflinger (pid 784)
        59,084K: android.hardware.camera.provider@2.4-service (pid 743)
        26,524K: transport (pid 23418)
        25,249K: logd (pid 597)
        11,413K: media.codec (pid 1303)
        10,648K: rild (pid 1304)
        9,283K: media.extractor (pid 1297)
        ...
        
    661,294K: Persistent
        225,081K: system (pid 2088)
        189,038K: com.android.systemui (pid 2297 / activities)
        103,050K: com.xiaomi.finddevice (pid 3134)
        39,098K: com.android.phone (pid 2656)
        25,583K: com.miui.daemon (pid 3078)
        ...
        
    219,795K: Foreground
        175,231K: json.chao.com.wanandroid (pid 23104 / activities)
        44,564K: com.miui.securitycenter.remote (pid 2986)
        
    246,529K: Visible
        71,002K: com.sohu.inputmethod.sogou.xiaomi (pid 4820)
        52,305K: com.miui.miwallpaper (pid 2579)
        40,982K: com.miui.powerkeeper (pid 3218)
        24,604K: com.miui.systemAdSolution (pid 7986)
        14,198K: com.xiaomi.metoknlp (pid 3506)
        13,820K: com.miui.voiceassist:core (pid 8722)
        13,222K: com.miui.analytics (pid 8037)
        7,046K: com.miui.hybrid:entrance (pid 7922)
        5,104K: com.miui.wmsvc (pid 7887)
        4,246K: com.android.smspush (pid 8126)
        
    213,027K: Perceptible
        89,780K: com.eg.android.AlipayGphone (pid 8238)
        49,033K: com.eg.android.AlipayGphone:push (pid 8204)
        23,181K: com.android.thememanager (pid 11057)
        13,253K: com.xiaomi.joyose (pid 5558)
        10,292K: com.android.updater (pid 3488)
        9,807K: com.lbe.security.miui (pid 23060)
        9,734K: com.google.android.webview:sandboxed_process0 (pid 11150)
        7,947K: com.xiaomi.location.fused (pid 3524)
        
    308,049K: Backup
        308,049K: com.tencent.mm (pid 3760 / activities)
        
    74,250K: A Services
        59,701K: com.tencent.mm:push (pid 7234)
        9,247K: com.android.settings:remote (pid 27053)
        5,302K: com.xiaomi.drivemode (pid 27009)
        
    199,638K: Home
        188,877K: com.miui.home (pid 2672 / activities)
        10,761K: com.miui.hybrid (pid 7945)
        
    53,934K: B Services
        35,583K: com.tencent.mobileqq:MSF (pid 14119)
        6,753K: com.qualcomm.qti.autoregistration (pid 8786)
        4,086K: com.qualcomm.qti.callenhancement (pid 26958)
        3,809K: com.qualcomm.qti.StatsPollManager (pid 26993)
        3,703K: com.qualcomm.qti.smcinvokepkgmgr (pid 26976)
        
    692,588K: Cached
        176,665K: com.plan.kot32.tomatotime (pid 22744 / activities)
        126,918K: com.tencent.mobileqq (pid 23741)
        72,928K: com.tencent.mm:tools (pid 18598)
        68,208K: com.tencent.mm:sandbox (pid 27333)
        55,270K: com.tencent.mm:toolsmp (pid 18842)
        24,477K: com.android.mms (pid 27192)
        23,865K: com.xiaomi.market (pid 27825)
        ...

// 按内存的类别来进行划分
Total PSS by category:
    957,931K: Native
    284,006K: Dalvik
    199,750K: Unknown
    193,236K: .dex mmap
    191,521K: .art mmap
    110,581K: .oat mmap
    101,472K: .so mmap
    94,984K: EGL mtrack
    87,321K: Dalvik Other
    84,924K: Gfx dev
    77,300K: GL mtrack
    64,963K: .apk mmap
    17,112K: Other mmap
    12,935K: Ashmem
     3,364K: Stack
     2,343K: .ttf mmap
     1,375K: Other dev
     1,071K: .jar mmap
        20K: Cursor
         0K: Other mtrack

// 手机整体内存使用情况
Total RAM: 5,847,124K (status normal)
Free RAM: 3,711,324K (  692,588K cached pss + 2,428,616K cached kernel +   117,492K cached ion +   472,628K free)
Used RAM: 2,864,761K (2,408,529K used pss +   456,232K kernel)
Lost RAM:   184,330K
    ZRAM:   174,628K physical used for   625,388K in swap (2,621,436K total swap)
Tuning: 256 (large 512), oom   322,560K, restore limit   107,520K (high-end-gfx)
<span class="copy-code-btn">复制代码</span></code></pre>
<p>根据 dumpsys meminfo 的输出结果，可归结为如下表格：</p>
<table>
<thead>
<tr>
<th>划分类型</th>
<th>排序指标</th>
<th>含义</th>
</tr>
</thead>
<tbody>
<tr>
<td>process</td>
<td>PSS</td>
<td>以进程的PSS从大到小依次排序显示，每行显示一个进程，一般用来做初步的竞品分析</td>
</tr>
<tr>
<td>OOM adj</td>
<td>PSS</td>
<td>展示当前系统内部运行的所有Android进程的内存状态和被杀顺序，越靠近下方的进程越容易被杀，排序按照一套复杂的算法，算法涵盖了前后台、服务或节目、可见与否、老化等</td>
</tr>
<tr>
<td>category</td>
<td>PSS</td>
<td>以Dalvik/Native/.art mmap/.dex map等划分并按降序列出各类进程的总PSS分布情况</td>
</tr>
<tr>
<td>total</td>
<td>-</td>
<td>总内存、剩余内存、可用内存、其他内存</td>
</tr>
</tbody>
</table>
<p>此外，为了 <strong>查看单个 App 进程的内存信息</strong>，我们可以输入如下命令：</p>
<pre><code class="copyable">dumpsys meminfo  // 输出指定pid的某一进程
dumpsys meminfo --package  // 输出指定包名的进程，可能包含多个进程
<span class="copy-code-btn">复制代码</span></code></pre>
<p>这里我们输入 adb shell dumpsys meminfo 23104 这条命令，其中 23104 为 Awesome-WanAndroid App 的 pid，结果如下所示：</p>
<pre><code class="copyable">quchao@quchaodeMacBook-Pro ~ % adb shell dumpsys meminfo 23104
Applications Memory Usage (in Kilobytes):
Uptime: 258375231 Realtime: 258375231

** MEMINFO in pid 23104 [json.chao.com.wanandroid] **
                Pss  Private  Private  SwapPss     Heap     Heap     Heap
                Total    Dirty    Clean    Dirty     Size    Alloc     Free
                ------   ------   ------   ------   ------   ------   ------
Native Heap    46674    46620        0      164    80384    60559    19824
Dalvik Heap     6949     6912       16       23    12064     6032     6032
Dalvik Other     7672     7672        0        0
       Stack      108      108        0        0
      Ashmem      134      132        0        0
     Gfx dev    16036    16036        0        0
   Other dev       12        0       12        0
   .so mmap     3360      228     1084       27
  .jar mmap        8        8        0        0
  .apk mmap    28279    11328    11584        0
  .ttf mmap      295        0       80        0
  .dex mmap     7780       20     4908        0
  .oat mmap      660        0       92        0
  .art mmap     8509     8028      104       69
 Other mmap      982        8      848        0
 EGL mtrack    29388    29388        0        0
  GL mtrack    14864    14864        0        0
    Unknown     2532     2500        8       20
      TOTAL   174545   143852    18736      303    92448    66591    25856

App Summary
                   Pss(KB)
                    ------
       Java Heap:    15044
     Native Heap:    46620
            Code:    29332
           Stack:      108
        Graphics:    60288
   Private Other:    11196
          System:    11957

           TOTAL:   174545       TOTAL SWAP PSS:      303

Objects
           Views:      171         ViewRootImpl:        1
     AppContexts:        3           Activities:        1
          Assets:       18        AssetManagers:        6
   Local Binders:       32        Proxy Binders:       27
   Parcel memory:       11         Parcel count:       45
Death Recipients:        1      OpenSSL Sockets:        0
        WebViews:        0

SQL
        MEMORY_USED:      371
 PAGECACHE_OVERFLOW:       72          MALLOC_SIZE:      117

DATABASES
    pgsz     dbsz   Lookaside(b)          cache  Dbname
        4       60            109      151/32/18  /data/user/0/json.chao.com.wanandroid/databases/bugly_db_
        4       20             19         0/15/1  /data/user/0/json.chao.com.wanandroid/databases/aws_wan_android.db
<span class="copy-code-btn">复制代码</span></code></pre>
<p>该命令输出了 <strong>进程的内存概要</strong>，我们应该着重关注 <strong>四个要点</strong>，下面我将一一进行讲解。</p>
<h4 class="heading" data-id="heading-148">1、查看 Native Heap 的 Heap Alloc 与 Dalvik Heap 的 Heap Alloc</h4>
<ul>
<li>1）、<strong>Heap Alloc：表示 native 的内存占用，如果持续上升，则可能有泄漏</strong>。</li>
<li>2）、<strong>Heap Alloc：表示 Java 层的内存占用</strong>。</li>
</ul>
<h4 class="heading" data-id="heading-149">2、查看 Views、Activities、AppContexts 数量变化情况</h4>
<p><strong>如果 Views 与 Activities、AppContexts 持续上升，则表明有内存泄漏的风险</strong>。</p>
<h4 class="heading" data-id="heading-150">3、SQL 的 MEMORY_USED 与 PAGECACHE_OVERFLOW</h4>
<ul>
<li>1）<strong>、MEMOERY_USED：表示数据库使用的内存</strong>。</li>
<li>2）、<strong>PAGECACHE_OVERFLOW：表示溢出也使用的缓存，这个数值越小越好</strong>。</li>
</ul>
<h4 class="heading" data-id="heading-151">4、查看 DATABASES 信息</h4>
<ul>
<li>1）、<strong>pgsz：表示数据库分页大小，这里全是 4KB</strong>。</li>
<li>2）、<strong>Lookaside(b)：表示使用了多少个 Lookaside 的 slots，可理解为内存占用的大小</strong>。</li>
<li>3）、<strong>cache：一栏中的 151/32/18 则分别表示 分页缓存命中次数/未命中次数/分页缓存个数，这里的未命中次数不应该大于命中次数</strong>。</li>
</ul>
<h2 class="heading" data-id="heading-152">3、LeakInspector</h2>
<p>LeakInspector 是腾讯内部的使用的 <strong>一站式内存泄漏解决方案</strong>，它是 Android 手机经过长期积累和提炼、<strong>集内存泄漏检测、自动修复系统Bug、自动回收已泄露Activity内资源、自动分析GC链、白名单过滤</strong> 等功能于一体，并 <strong>深度对接研发流程、自动分析责任人并提缺陷单的全链路体系</strong>。</p>
<h3 class="heading" data-id="heading-153">那么，LeakInspector 与 LeakCanary 又有什么不同之处呢？</h3>
<p>它们之间主要有 <strong>四个方面</strong> 的不同，如下所示：</p>
<h4 class="heading" data-id="heading-154">一、检测能力与原理方面不同</h4>
<h5 class="heading" data-id="heading-155">1、检测能力</h5>
<p>它们都支持对 Activity、Fragment 及其它自定义类的泄漏检测，但是，LeakInspector 还 <strong>增加了 Btiamp 的检测能力</strong>，如下所示：</p>
<ul>
<li>1）、检测有没有在 View 上 decode 超过该 View 尺寸的图片，若有则上报出现问题的 Activity 及与其对应的 View id，并记录它的个数与平均占用内存的大小。</li>
<li>2）、检测图片尺寸是否超过所有手机屏幕大小，违规则报警。</li>
</ul>
<p>这一个部分的实现原理，我们可以采用 ARTHook 的方式来实现，还不清楚的朋友请再仔细看看大图检测的部分。</p>
<h5 class="heading" data-id="heading-156">2、检测原理</h5>
<p>两个工具的泄漏检测原理都是在 onDestroy 时检查弱引用，<strong>不同之处在于 LeakInspector 直接使用 WeakReference 来检测对象是否已经被释放</strong>，而 LeakCanary 则使用 ReferenceQueue，两者效果是一样的。</p>
<p>并且针对 Activity，我们通常都会使用 Application的 registerActivityLifecycleCallbacks 来注册 Activity 的生命周期，以重写 onActivityDestroyed 方法实现。但是在 <strong>Android 4.0 以下</strong>，系统并没有提供这个方法，为了避免手动在每一个 Activity 的 onDestroy 中去添加这份代码，我们可以使用 <strong>反射 Instrumentation 来截获 onDestory</strong>，以降低接入成本。代码如下所示：</p>
<pre><code class="copyable">Class&lt;?&gt; clazz = Class.forName("android.app.ActivityThread");
Method method = clazz.getDeclaredMethod("currentActivityThread", null);
method.setAccessible(true);
sCurrentActivityThread = method.invoke(null, null);
Field field = sCurrentActivityThread.getClass().getDeclaredField("mInstumentation");
field.setAccessible(true);
field.set(sCurrentActivityThread, new MonitorInstumentation());
<span class="copy-code-btn">复制代码</span></code></pre>
<h4 class="heading" data-id="heading-157">二、泄漏现场处理方面不同</h4>
<h5 class="heading" data-id="heading-158">1、dump 采集</h5>
<p>两者都能采集 dump，但是 LeakInspector 提供了<strong>回调方法</strong>，我们可以<strong>增加更多的自定义信息</strong>，如运行时 Log、trace、dumpsys meminfo 等信息，以辅助分析定位问题。</p>
<h5 class="heading" data-id="heading-159">2、白名单定义</h5>
<p>这里的白名单是为了处理一些系统引起的泄漏问题，以及一些因为 <strong>业务逻辑要开后门的情形而设置</strong> 的。分析时如果碰到白名单上标识的类，则不对这个泄漏做后续的处理。二者的配置差异有如下两点：</p>
<ul>
<li>
<p>1）、LeakInspector 的白名单以 XML 配置的形式存放在服务器上。</p>
<ul>
<li>优点：跟产品甚至不同版本的应用绑定，我们可以很方便地修改相应的配置。</li>
<li>缺点：白名单里的类不区分系统版本一刀切。</li>
</ul>
</li>
<li>
<p>1）、而LeakCanary的白名单是直接写死在其源码的AndroidExcludedRefs类里。</p>
<ul>
<li>优点：定义非常详细，并区分系统版本。</li>
<li>缺点：每次修改必定得重新编译。</li>
</ul>
</li>
<li>
<p>2）、LeakCanary 的系统白名单里定义的类比 LeakInspector 中定义的多很多，因为它没有自动修复系统泄漏功能。</p>
</li>
</ul>
<h5 class="heading" data-id="heading-160">3、自动修复系统泄漏</h5>
<p>针对系统泄漏，LeakInspector 通过 <strong>反射自动修复</strong> 了目前碰到的一些系统泄漏，只要在 <strong>onDestory</strong> 里面 <strong>调用</strong> 一个修复系统泄漏的方法即可。而 LeakCanary 虽然能识别系统泄漏，但是它仅仅对该类问题给出了分析，没有提供实际可用的解决方案。</p>
<h5 class="heading" data-id="heading-161">4、回收资源（Activity内存泄漏兜底处理）</h5>
<p>如果检测到发生了内存泄漏，LeakInspector 会对整个 Activity 的 View 进行遍历，把图片资源等一些占内存的数据释放掉，保证此次泄漏只会泄漏一个Activity的空壳，尽量减少对内存的影响。代码大致如下所示：</p>
<pre><code class="copyable">if (View instanceof ImageView) {
    // ImageView ImageButton处理
    recycleImageView(app, (ImageView) view);
} else if (view instanceof TextView) {
    // 释放TextView、Button周边图片资源
    recycleTextView((TextView) view);
} else if (View instanceof ProgressBar) {
    recycleProgressBar((ProgressBar) view);
} else {
    if (view instancof android.widget.ListView) {
        recycleListView((android.widget.ListView) view);
    } else if (view instanceof android.support.v7.widget.RecyclerView) {
        recycleRecyclerView((android.support.v7.widget.RecyclerView) view);
    } else if (view instanceof FrameLayout) {
        recycleFrameLayout((FrameLayout) view);
    } else if (view instanceof LinearLayout) {
        recycleLinearLayout((LinearLayout) view);
    }
    
    if (view instanceof ViewGroup) {
        recycleViewGroup(app, (ViewGroup) view);
    }
}
<span class="copy-code-btn">复制代码</span></code></pre>
<p>这里以 recycleTextView 为例，它回收资源的方式如下所示：</p>
<pre><code class="copyable">private static void recycleTextView(TextView tv) {
    Drawable[] ds = tv.getCompoundDrawables();
    for (Drawable d : ds) {
        if (d != null) {
            d.setCallback(null);
        }
    }
    tv.setCompoundDrawables(null, null, null, null);
    // 取消焦点，让Editor$Blink这个Runnable不再被post，解决内存泄漏。
    tv.setCursorVisible(false);
}
<span class="copy-code-btn">复制代码</span></code></pre>
<h4 class="heading" data-id="heading-162">三、后期处理不同</h4>
<h5 class="heading" data-id="heading-163">1、分析与展示</h5>
<p>采集 dump 之后，LeakInspector 会上传 dump 文件，并* <em>调用 MAT 命令行来进行分析</em>*，得到这次泄漏的 GC 链。而 LeakCanary 则用开源组件 HAHA 来分析得到一个 GC 链。但是 LeakCanary 得到的 GC 链包含被 hold 住的类对象，一般都不需要用 MAT 打开 Hporf 即可解决问题。而 LeakInpsector 得到的 GC 链只有类名，还需要 MAT 打开 Hprof 才能具体去定位问题，不是很方便。</p>
<h5 class="heading" data-id="heading-164">2、后续跟进闭环</h5>
<p>LeakInspector <strong>在 dump 分析结束之后，会提交缺陷单，并且把缺陷单分配给对应类的负责人。如果发现重复的问题则更新旧单，同时具备重新打开单等状态转换逻辑</strong>。而 LeakCanary 仅会在通知栏提醒用户，需要用户自己记录该问题并做后续处理。</p>
<h4 class="heading" data-id="heading-165">四、配合自动化测试方面不同</h4>
<p>LeakInspector 跟自动化测试可以无缝结合，当自动化脚本执行中发现内存泄漏，可以由它采集 dump 并发送到服务进行分析，最后提单，整个流程是不需要人力介入的。而 LeakCanary 则把分析结果通过通知栏告知用户，需要人工介入才能进入下一个流程。</p>
<h2 class="heading" data-id="heading-166">4、JHat</h2>
<p>JHat 是 Oracle 推出的一款 Hprof 分析软件，它和 MAT 并称为 Java 内存静态分析利器。不同于 MAT 的单人界面式分析，jHat <strong>使用多人界面式分析</strong>。它被 <strong>内置在 JDK 中</strong>，在命令行中输入 jhat 命令可查看有没有相应的命令。</p>
<pre><code class="copyable">quchao@quchaodeMacBook-Pro ~ % jhat
ERROR: No arguments supplied
Usage:  jhat [-stack ] [-refs ] [-port ] [-baseline ] [-debug ] [-version] [-h|-help] 

    -J          Pass  directly to the runtime system. For
		    example, -J-mx512m to use a maximum heap size of 512MB
    -stack false:     Turn off tracking object allocation call stack.
    -refs false:      Turn off tracking of references to objects
    -port :     Set the port for the HTTP server.  Defaults to 7000
    -exclude :  Specify a file that lists data members that should
		    be excluded from the reachableFrom query.
    -baseline : Specify a baseline object dump.  Objects in
		    both heap dumps with the same ID and same class will
		    be marked as not being "new".
    -debug :     Set debug level.
		        0:  No debug output
		        1:  Debug hprof file parsing
		        2:  Debug hprof file parsing, no server
    -version          Report version number
    -h|-help          Print this help and exit
                The file to read

For a dump file that contains multiple heap dumps,
you may specify which dump in the file
by appending "#" to the file name, i.e. "foo.hprof#3".
<span class="copy-code-btn">复制代码</span></code></pre>
<p>出现如上输出，则表明存在 jhat 命令。它的使用很简单，直在命令行输入 jhat xxx.hprof 即可，如下所示：</p>
<pre><code class="copyable">quchao@quchaodeMacBook-Pro ~ % jhat Documents/heapdump/new-33.hprof
Snapshot read, resolving...
Resolving 408200 objects...
Chasing references, expect 81 dots.................................................................................
Eliminating duplicate references.................................................................................
Snapshot resolved.
Started HTTP server on port 7000
Server is ready.
<span class="copy-code-btn">复制代码</span></code></pre>
<p><strong>jHat 的执行过程是解析 Hprof 文件，然后启动 httpsrv 服务，默认是在 7000 端口监听 Web 客户端链接，维护 Hprof 解析后的数据，以持续供给 Web 客户端进行查询操作</strong>。</p>
<p>启动服务器后，我们打开 <strong>入口地址 127.0.0.1:7000</strong> 即可查看 <strong>All Classes</strong> 界面，如下图所示：</p>
<figure><img class="lazyload" src="./干货集中营_files/7201d837e1f1431ba9ff9382bbafa099" alt="image" data-height="631" data-width="1280">
<figcaption></figcaption>
</figure>
<p>jHat 还有两个比较重要的功能，分别如下所示：</p>
<h3 class="heading" data-id="heading-167">1、统计表</h3>
<p>打开 127.0.0.1:7000/histo/，统计表界面如下所示：</p>
<figure><img class="lazyload" src="./干货集中营_files/04437d01edd74e7a9141da95200b1dcd" alt="image" data-height="687" data-width="1280">
<figcaption></figcaption>
</figure>
<p>可以到，按 Total Size 降序 排列了所有的 Class，并且，我们还可以查看到每一个 Class 与之对应的实例数量。</p>
<h3 class="heading" data-id="heading-168">2、OQL 查询</h3>
<p>OQL 是一种模仿 SQL 语句的查询语句，通常用来查询某个类的实例数量，打开 <strong>127.0.0.1:7000/oql/</strong> 并输入 java.lang.String 查询 String 实例的数量，结果如下图所示：</p>
<figure><img class="lazyload" src="./干货集中营_files/bd790e758bfa42ffa6df3767fbdfbab2" alt="image" data-height="620" data-width="1280">
<figcaption></figcaption>
</figure>
<p><strong>JHat 比 MAT 更加灵活，且符合大型团队安装简单、团队协作的需求</strong>。但是，并不适合中小型高效沟通型团队使用。</p>
<h2 class="heading" data-id="heading-169">5、ART GC Log</h2>
<p>GC Log 分为 Dalvik 和 ART 的 GC 日志，关于 Dalvik 的 GC 日志，我们在前篇 <a href="https://jsonchao.github.io/2019/08/18/Android%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96%E4%B9%8B%E5%86%85%E5%AD%98%E4%BC%98%E5%8C%96/" target="_blank" rel="nofollow noopener noreferrer">Android性能优化之内存优化</a> 中已经详细讲解过了，接下来我们说说 <strong>ART 的 GC 日志</strong>。</p>
<p>ART 的日志与 Dalvik 的日志差距非常大，除了格式不同之外，打印的时间也不同，而且，它只有在慢 GC 时才会打印出来。下面我们看看这条 ART GC Log：</p>
<table>
<thead>
<tr>
<th>Explicit</th>
<th>（full）</th>
<th>concurrent mark sweep GC</th>
<th>freed 104710 （7MB） AllocSpace objects,</th>
<th>21（416KB） LOS objects，</th>
<th>33% free,25MB/38MB</th>
<th>paused 1.230ms total 67.216ms</th>
</tr>
</thead>
<tbody>
<tr>
<td>GC产生的原因</td>
<td>GC类型</td>
<td>采集方法</td>
<td>释放的数量和占用的空间</td>
<td>释放的大对象数量和所占用的空间</td>
<td>堆中空闲空间的百分比和（对象的个数）/（堆的总空间）</td>
<td>暂停耗时</td>
</tr>
</tbody>
</table>
<h3 class="heading" data-id="heading-170">GC 产生的原因</h3>
<p>GC 产生的原因有如下九种：</p>
<ul>
<li>1）、<strong>Concurrent、Alloc、Explicit</strong> 跟 Dalvik 的基本一样，这里就不重复介绍了。</li>
<li>2）、<strong>NativeAlloc：Native 内存分配时，比如为 Bitmaps 或者 RenderScript 分配对象， 这会导致Native内存压力，从而触发GC</strong>。</li>
<li>3）、<strong>Background：后台 GC，触发是为了给后面的内存申请预留更多空间</strong>。</li>
<li>4）、<strong>CollectorTransition：由堆转换引起的回收，这是运行时切换 GC 而引起的。收集器转换包括将所有对象从空闲列表空间复制到碰撞指针空间（反之亦然）。当前，收集器转换仅在以下情况下出现：在内存较小的设备上，App 将进程状态从可察觉的暂停状态变更为可察觉的非暂停状态（反之亦然）</strong>。</li>
<li>5）、<strong>HomogeneousSpaceCompact：齐性空间压缩是指空闲列表到压缩的空闲列表空间，通常发生在当 App 已经移动到可察觉的暂停进程状态。这样做的主要原因是减少了内存使用并对堆内存进行碎片整理</strong>。</li>
<li>6）、<strong>DisableMovingGc：不是真正的触发 GC 原因，发生并发堆压缩时，由于使用了 GetPrimitiveArrayCritical，收集会被阻塞。一般情况下，强烈建议不要使用 GetPrimitiveArrayCritical</strong>。</li>
<li>7）、<strong>HeapTrim：不是触发GC原因，但是请注意，收集会一直被阻塞，直到堆内存整理完毕</strong>。</li>
</ul>
<h3 class="heading" data-id="heading-171">GC 类型</h3>
<p>GC 类型有如下三种：</p>
<ul>
<li>1）、<strong>Full：与Dalvik的 FULL GC 差不多</strong>。</li>
<li>2）、<strong>Partial：跟 Dalvik 的局部 GC 差不多，策略时不包含 Zygote Heap</strong>。</li>
<li>3）、<strong>Sticky：另外一种局部中的局部 GC，选择局部的策略是上次垃圾回收后新分配的对象</strong>。</li>
</ul>
<h3 class="heading" data-id="heading-172">GC采集的方法</h3>
<p>GC 采集的方法有如下四种：</p>
<ul>
<li>1）、<strong>mark sweep：先记录全部对象，然后从 GC ROOT 开始找出间接和直接的对象并标注。利用之前记录的全部对象和标注的对象对比，其余的对象就应该需要垃圾回收了</strong>。</li>
<li>2）、<strong>concurrent mark sweep：使用 mark sweep 采集器的并发 GC</strong>。</li>
<li>3）、<strong>mark compact：在标记存活对象的时候，所有的存活对象压缩到内存的一端，而另一端可以更加高效地被回收</strong>。</li>
<li>4）、<strong>semispace：在做垃圾扫描的时候，把所有引用的对象从一个空间移到另外一个空间，然后直接 GC 剩余在旧空间中的对象即可</strong>。</li>
</ul>
<p>通过 GC 日志，我们可以知道 <strong>GC 的量和 它对卡顿的影响</strong>，也可以 <strong>初步定位一些如主动调用GC、可分配的内存不足、过多使用Weak Reference</strong> 等问题。</p>
<h2 class="heading" data-id="heading-173">6、Chrome Devtool</h2>
<p>对于 HTML5 页面而言，抓取 JavaScript 的内存需要使用 Chrome Devtools 来进行远程调试。方式有如下两种：</p>
<ul>
<li>1）、直接把 URL 抓取出来放到 Chrome 里访问。</li>
<li>2）、用 Android H5 远程调试。</li>
</ul>
<h3 class="heading" data-id="heading-174">纯H5</h3>
<h4 class="heading" data-id="heading-175">1、手机安装 Chrome，打开 USB 调试模式，通过 USB 连上电脑，在 Chrome 里打开一个页面，比如百度页面。然后在 PC Chrome 地址栏里访问 Chrome://inspect，如下图所示：</h4>
<figure><img class="lazyload" src="./干货集中营_files/3c4503c108814e4cadbdc77e77d20dce" alt="image" data-height="688" data-width="1280">
<figcaption></figcaption>
</figure>
<h4 class="heading" data-id="heading-176">2、最后，直接点击 Chrome 下面的 inspect 选项即可弹出开发者工具界面。如下图所示：</h4>
<figure><img class="lazyload" src="./干货集中营_files/d5ff8ae2d4da4f6298c589b39b40c7af" alt="image" data-height="1266" data-width="1280">
<figcaption></figcaption>
</figure>
<h4 class="heading" data-id="heading-177">默认 Hybrid H5 调试</h4>
<p>Android 4.4 及以上系统的原生浏览器就是 Chrome 浏览器，可以使用 Chrome Devtool 远程调试 WebView，前提是需要在 App 的代码里把调试开关打开，如下代码所示：</p>
<pre><code class="copyable">if (Build.VERSION_SDK_INT &gt;= Build.VERSION_CODES.KITKAT &amp;&amp; 是debug模式) {
    WebView.setWebContentsDebuggingEnabled(ture);
}
<span class="copy-code-btn">复制代码</span></code></pre>
<p>打开后的调试方法跟纯 H5 页面调试方法一样，直接在 App 中打开 H5 页面，再到 PC Chrome 的 inpsector 页面就可以看到调试目标页面。</p>
<p>这里总结一下 <strong>JS 中几种常见的内存问题点</strong>：</p>
<ul>
<li>1）、<strong>closure 闭包函数</strong>。</li>
<li>2）、<strong>事件监听</strong>。</li>
<li>3）、<strong>变量作用域使用不当，全局变量的引用导致无法释放</strong>。</li>
<li>4）、<strong>DOM 节点的泄漏</strong>。</li>
</ul>
<p>若想更深入地学习 Chrome 开发者工具的使用方法，请查看 <a href="https://github.com/CN-Chrome-DevTools/CN-Chrome-DevTools" target="_blank" rel="nofollow noopener noreferrer">《Chrome开发者工具中文手册》</a>。</p>
<h1 class="heading" data-id="heading-178">八、内存问题总结</h1>
<p>在我们进行内存优化的过程中，<strong>有许多内存问题都可以归结为一类问题，为了便于以后快速地解决类似的内存问题，我将它们归结成了以下的多个要点</strong>：</p>
<h2 class="heading" data-id="heading-179">1、内类是有危险的编码方式</h2>
<p>说道内类就不得不提到 ”<strong>this$0“</strong>，它是一种奇特的内类成员，每个类实例都具有一个 this$0，当它的内类需要访问它的成员时，内类就会持有外类的 this$0，通过 this$0 就可以访问外部类所有的成员。</p>
<p>解决方案是在 Activity 关闭，即触发 onDestory 时解除内类和外部的引用关系。</p>
<h2 class="heading" data-id="heading-180">2、普通 Hanlder 内部类的问题</h2>
<p>这也是一个 this$0 间接引用的问题，对于 Handler 的解决方案一般可以归结为如下三个步骤：</p>
<ul>
<li>1）、<strong>把内类声明成 static：用来断绝 this$0 的引用。因为 static 描述的内类从 Java 编译原理的角度看，”内类“与”外类“相互独立，互相都没有访问对方成员变量的能力</strong>。</li>
<li>2、<strong>使用 WeakReference 来引用外部类的实例</strong>。</li>
<li>3、<strong>在外部类（如 Activity）销毁的时候使用 removeCallbackAndMessages 来移除回调和消息</strong>。</li>
</ul>
<p>这里需要在使用过程中<strong>注意对 WeakReference 进行判空</strong>。</p>
<h2 class="heading" data-id="heading-181">3、登录界面的内存问题</h2>
<p>如果在闪屏页跳转到登录界面时没有调用 finish()，则会造成闪屏页的内存泄漏，在<strong>碰到这种”过渡界面“的情况时，需要注意不要产生这样的内存 Bug</strong>。</p>
<h2 class="heading" data-id="heading-182">4、使用系统服务时产生的内存问题</h2>
<p>我们通常都会使用 getSystemService 方法来获取系统服务，但是当在 Activity 中调用时，会默认把 Activity 的 Context 传给系统服务，在某些不确定的情况下，某些系统服务内部会产生异常，从而 hold 住外界传入的 Context。</p>
<p>解决方案是 <strong>直接使用 Applicaiton 的 Context 去获取系统服务</strong>。</p>
<h2 class="heading" data-id="heading-183">5、把 WebView 类型的泄漏装进垃圾桶进程</h2>
<p>我们都知道，对应 WebView 来说，其 <strong>网络延时、引擎 Session 管理、Cookies 管理、引擎内核线程、HTML5 调用系统声音、视频播放组件等产生的引用链条无法及时打断</strong>，造成的内存问题基本上可以用”无解“来形容。</p>
<p>解决方案是我们可以 <strong>把 WebView 装入另一个进程</strong>。 具体为<strong>在 AndroidManifes 中对当前的 Activity 设置 android:process 属性即可，最后，在 Activity 的 onDestory 中退出进程，这样即可基本上终结 WebView 造成的泄漏</strong>。</p>
<h2 class="heading" data-id="heading-184">6、在适当的时候对组件进行注销</h2>
<p>我们在平常开发过程中经常需要在Activity创建的时候去注册一些组件，如广播、定时器、事件总线等等。这个时候我们应该在适当的时候对组件进行注销，如 <strong>onPause 或 onDestory 方法中</strong>。</p>
<h2 class="heading" data-id="heading-185">7、Handler / FrameLayout 的 postDelyed 方法触发的内存问题</h2>
<p>不仅在使用 Handler 的 sendMessage 方法时，我们需要在 onDestory 中使用 removeCallbackAndMessage 移除回调和消息，在使用到 Handler / FrameLayout 的 postDelyed 方法时，我们需要<strong>调用 removeCallbacks 去移除实现控件内部的延时器对 Runnable 内类的持有</strong>。</p>
<h2 class="heading" data-id="heading-186">8、图片放错资源目录也会有内存问题</h2>
<p>在做资源适配的时候，因为需要考虑到 APK 的瘦身问题，无法为每张图片在每个 drawable / mipmap 目录下安置一张适配图片的副本。很多同学不知道图片应该放哪个目录，如果放到分辨率低的目录如 hdpi 目录，则可能会造成内存问题，这个时候<strong>建议尽量问设计人员要高品质图片然后往高密度目录下方，如 xxhdpi 目录</strong>，这样 <strong>在低密屏上”放大倍数“是小于1的</strong>，在保证画质的前提下，内存也是可控的。<strong>也可以使用 Drawable.createFromSream 替换 getResources().getDrawable 来加载，这样便可以绕过 Android 的默认适配规则</strong>。</p>
<p>对于已经被用户使用物理“返回键”退回到后台的进程，如果包含了以下 <strong>两点</strong>，则 <strong>不会被轻易杀死</strong>。</p>
<ul>
<li>1）、<strong>进程包含了服务 startService，而服务本身调用了 startForeground（低版本需通过反射调用）</strong>。</li>
<li>2）、<strong>主 Activity 没有实现 onSaveInstanceState 接口</strong>。</li>
</ul>
<p>但建议 <strong>在运行一段时间（如3小时）后主动保存界面进程（位于后台），然后重启它，这样可以有效地降低内存负载</strong>。</p>
<h2 class="heading" data-id="heading-187">9、列表 item 被回收时注意释放图片的引用</h2>
<p>我们应该在 item 被回收不可见时去释放掉对图片的引用。如果你使用的是 <strong>ListView</strong>，由于每次 item 被回收后被再次利用都会去重新绑定数据，所以只需<strong>在 ImageView 回调其 onDetchFromWindow 方法的时候区释放掉图片的引用即可</strong>。如果你使用的是 <strong>RecyclerView</strong>，因为被回收不可见时第一次选择是放进 mCacheView中，但是这里面的 item 被复用时并不会去执行 bindViewHolder 来重新绑定数据，只有被回收进 mRecyclePool 后拿出来复用才会重新绑定数据。所以此时我们应该<strong>在 item 被回收进 RecyclePool 的时候去释放图片的引用</strong>，这里我们只要去 <strong>重写 Adapter 中的 onViewRecycled 方法</strong> 就可以了，代码如下所示：</p>
<pre><code class="copyable">@Override
public void onViewRecycled(@Nullable VH holder) {
    super.onViewRecycled(holder);
    if (holder != null) {
        //做释放图片引用的操作
    }
}
<span class="copy-code-btn">复制代码</span></code></pre>
<h2 class="heading" data-id="heading-188">10、使用 ViewStub 进行占位</h2>
<p>我们应该使用 ViewStub <strong>对那些没有马上用到的资源去做延迟加载</strong>，并且还有<strong>很多大概率不会出现的 View 更要去做懒加载</strong>，这样可以等到要使用时再去为它们分配相应的内存。</p>
<h2 class="heading" data-id="heading-189">11、注意定时清理 App 过时的埋点数据</h2>
<p>产品或者运营为了统计数据会在每个版本中不断地增加新的埋点。所以我们需要定期地去清理一些过时的埋点，以此来 <strong>适当地优化内存以及CPU的压力</strong>。</p>
<h2 class="heading" data-id="heading-190">12、针对匿名内部类 Runnable 造成内存泄漏的处理</h2>
<p>我们在做子线程操作的时候，喜欢使用匿名内部类 Runnable 来操作。但是，如果某个 Activity 放在线程池中的任务不能及时执行完毕，在 Activity 销毁时很容易导致内存泄漏。因为这个<strong>匿名内部类 Runnable 类持有一个指向 Outer 类的引用，这样一来如果 Activity 里面的 Runnable 不能及时执行，就会使它外围的 Activity 无法释放，产生内存泄漏</strong>。从上面的分析可知，<strong>只要在 Activity 退出时没有这个引用即可</strong>，那我们就<strong>通过反射，在 Runnable 进入线程池前先干掉它</strong>，代码如下所示：</p>
<pre><code class="copyable">Field f = job.getClass().getDeclaredField("this$0");
f.setAccessible(true);
f.set(job, null);
<span class="copy-code-btn">复制代码</span></code></pre>
<p>这个任务就是我们的 Runnable 对象，而 ”this$0“ 就是上面所指的外部类的引用了。这里注意使用 WeakReference 装起来，要执行了先 get 一下，如果是 null 则说明 Activity 已经回收，任务就放弃执行。</p>
<h1 class="heading" data-id="heading-191">九、内存优化常见问题</h1>
<h2 class="heading" data-id="heading-192">1、你们内存优化项目的过程是怎么做的？</h2>
<h3 class="heading" data-id="heading-193">1、分析现状、确认问题</h3>
<p>我们发现我们的 APP 在内存方面可能存在很大的问题，第一方面的原因是我们的线上的 OOM 率比较高。</p>
<p>第二点呢，我们经常会看到在我们的 Android Studio 的 Profiler 工具中内存的抖动比较频繁。</p>
<p>这是我们一个初步的现状，然后在我们知道了这个初步的现状之后，进行了问题的确认，我们经过一系列的调研以及深入研究，我们最终发现我们的项目中存在以下几点大问题，比如说：<strong>内存抖动、内存溢出、内存泄漏，还有我们的Bitmap 使用非常粗犷</strong>。</p>
<h3 class="heading" data-id="heading-194">2、针对性优化</h3>
<p>比如 <strong>内存抖动的解决 =&gt; Memory Profiler 工具的使用（呈现了锯齿张图形） =&gt; 分析到具体代码存在的问题（频繁被调用的方法中出现了日志字符串的拼接）</strong>，也可以说说 <strong>内存泄漏或内存溢出的解决</strong>。</p>
<h3 class="heading" data-id="heading-195">3、效率提升</h3>
<p>为了不增加业务同学的工作量，我们使用了一些工具类或 <strong>ARTHook</strong> 这样的 <strong>大图检测方案，没有任何的侵入性</strong>。同时，我们将这些技术教给了大家，然后让大家一起进行 <strong>工作效率上的提升</strong>。</p>
<p>我们对内存优化工具Profiler Memory、MAT 的使用比较熟悉，因此 <strong>针对一系列不同问题的情况</strong>，我们写了 <strong>一系列解决方案的文档</strong>，分享给大家。这样，我们 <strong>整个团队成员的内存优化意识就变强</strong> 了。</p>
<h2 class="heading" data-id="heading-196">2、你做了内存优化最大的感受是什么？</h2>
<h3 class="heading" data-id="heading-197">1、磨刀不误砍柴工</h3>
<p>我们一开始并没有直接去分析项目中代码哪些地方存在内存问题，而是先去学习了 Google 官方的一些文档，比如说学习了 Memory Profiler 工具的使用、学习了 MAT 工具的使用，在我们将这些工具学习熟练之后，当在我们的项目中遇到内存问题时，我们就能够很快地进行排查定位问题进行解决。</p>
<h3 class="heading" data-id="heading-198">2、技术优化必须结合业务代码</h3>
<p>一开始，我们做了整体 APP 运行阶段的一个内存上报，然后，我们在一些重点的内存消耗模块进行了一些监控，但是，后面发现这些监控并没有紧密地结合我们的业务代码，比如说在梳理完项目之后，发现我们项目中存在使用多个图片库的情况，<strong>多个图片库的内存缓存肯定是不公用的</strong>，所以 <strong>导致我们整个项目的内存使用量非常高</strong>。所以进行技术优化时必须结合我们的业务代码。</p>
<h3 class="heading" data-id="heading-199">3、系统化完善解决方案</h3>
<p>我们在做内存优化的过程中，不仅做了 Android 端的优化工作，还将我们 Android 端一些数据的采集上报到了我们的服务器，然后传到我们的 APM 后台，这样，方便我们的无论是 Bug 跟踪人员或者是 Crash 跟踪人员进行一系列问题的解决。</p>
<h2 class="heading" data-id="heading-200">3、如何检测所有不合理的地方？</h2>
<p>比如说 <strong>大图片的检测</strong>，我们最初的一个方案是通过<strong>继承 ImageView</strong>，<strong>重写</strong> 它的 <strong>onDraw</strong> 方法来实现。但是，我们在推广它的过程中，发现很多开发人员并不接受，因为很多 ImageView 之前已经写过了，你现在让他去替换，工作成本是比较高的。所以说，后来我们就想，有没有一种方案可以 <strong>免替换</strong>，最终我们就找到了 <strong>ARTHook</strong> 这样一个 Hook 的方案。</p>
<h1 class="heading" data-id="heading-201">十、总结</h1>
<p>对于 <strong>内存优化的专项优化</strong> 而言，我们要着重注意两点，即 <strong>优化大方向 和 优化细节</strong>。</p>
<h2 class="heading" data-id="heading-202">1、优化大方向</h2>
<p>对于 <strong>优化的大方向</strong>，我们应该 <strong>优先去做见效快的地方</strong>，主要有以下三部分：</p>
<ul>
<li>1）、<strong>内存泄漏</strong></li>
<li>2）、<strong>内存抖动</strong></li>
<li>3）、<strong>Bitmap</strong></li>
</ul>
<h2 class="heading" data-id="heading-203">2、优化细节</h2>
<p>对于 <strong>优化细节</strong>，我们应该 <strong>注意一些系统属性或内存回调的使用</strong> 等等，主要可以细分为如下六部分：</p>
<ul>
<li>1）、<strong>LargeHeap 属性</strong></li>
<li>2）、<strong>onTrimMemory / onLowMemory</strong></li>
<li>3）、<strong>使用优化过后的集合：如 SparseArray 类簇</strong></li>
<li>4）、<strong>谨慎使用 SharedPreference</strong></li>
<li>5）、<strong>谨慎使用外部库</strong></li>
<li>6）、<strong>业务架构设计合理</strong></li>
</ul>
<h2 class="heading" data-id="heading-204">3、内存优化体系化建设总结</h2>
<p>在这篇文章中，我们除了建立了 <strong>内存的监控闭环</strong> 这一核心体系之外，还实现了以下 <strong>十大组件 / 策略</strong>：</p>
<ul>
<li>1）、<strong>根据设备分级来使用不同的内存和分配回收策略</strong>。</li>
<li>2）、<strong>针对低端机做了功能或图片加载格式的降级处理</strong>。</li>
<li>3）、<strong>针对缓存滥用的问题实现了统一的缓存管理组件</strong>。</li>
<li>4）、<strong>实现了大图监控和重复图片的监控</strong>。</li>
<li>5）、<strong>在前台每隔一定时间去获取当前应用内存占最大内存的比例，当超过设定阈值时则主动释放应用 cache</strong>。</li>
<li>6）、<strong>当 UI 隐藏时释放内存以增加系统缓存应用进程的能力</strong>。</li>
<li>7）、<strong>高效实现了应用全局内的 Bitmap 监控</strong>。</li>
<li>8）、<strong>实现了全局的线程监控</strong>。</li>
<li>9）、<strong>针对内存使用的重度场景实现了 GC 监控</strong>。</li>
<li>10）、<strong>实现了线下的 native 内存泄漏监控</strong>。</li>
</ul>
<p>最后，当监控到 <strong>应用内存超过阈值时</strong>，还定制了 <strong>完善的兜底策略</strong> 来 <strong>重启应用进程</strong>。</p>
<p>总的来看，要建立一套 <strong>全面且成体系的内存优化及监控</strong> 是非常重要也是极具挑战性的一项工作。并且，目前各大公司的 <strong>内存优化体系</strong> 也正处于 <strong>不断演进的历程</strong> 之中，其目的不外乎：<strong>实现更健全的功能、更深层次的定位问题、快速准确地发现线上问题</strong></p>
                
            </div>
        </div>
        
        <div class="card-footer border-0">
    <div id="post-share-section" class="d-flex align-items-center justify-content-between justify-content-md-start text-center text-md-left py-2">
        <a class=" btn-link-like mr-md-4 mx-1 " href="https://gank.io/login" data-toggle="tooltip" data-placement="top" title="" data-action="like" data-id="5e79880393b891c522d3bde6" data-original-title="请先登录">
            <i class="text-md iconfont icon-thumb-up-line mx-1"></i><small class="like-count">11</small></a>
        <a href="https://gank.io/post/5e79880393b891c522d3bde6#comments" class="mr-md-4"><i class="text-xl iconfont icon-message--line"></i> <small class="font-theme text-md">0</small></a>

        <div class="d-none d-md-flex flex-md-fill"></div>
        <div class="content-share">
            <a href="javascript:;" role="button" class="link-post-share mx-2">
                <i class="text-xl iconfont icon-share-box-fill"></i>
                <i class="text-xl iconfont icon-close-fill"></i>
            </a>
            <div class="nice-dropdown">
                <div class="dropdown-inner">
                    <div class="row no-gutters">
                        <div class="col">
                            <a href="https://service.weibo.com/share/share.php?url=http%3A//gank.io/post/5e79880393b891c522d3bde6%3FAndroid%E7%BB%99%E6%AF%8F%E4%B8%AA%E5%BA%94%E7%94%A8%E8%BF%9B%E7%A8%8B%E5%88%86%E9%85%8D%E7%9A%84%E5%86%85%E5%AD%98%E9%83%BD%E6%98%AF%E9%9D%9E%E5%B8%B8%E6%9C%89%E9%99%90%E7%9A%84%EF%BC%8C%E9%82%A3%E4%B9%88%EF%BC%8C%E4%B8%BA%E4%BB%80%E4%B9%88%E4%B8%8D%E8%83%BD%E6%8A%8A%E5%9B%BE%E7%89%87%E4%B8%8B%E8%BD%BD%E4%B8%8B%E6%9D%A5%E9%83%BD%E6%94%BE%E5%88%B0%E7%A3%81%E7%9B%98%E4%B8%AD%E5%91%A2%EF%BC%9F%E9%82%A3%E6%98%AF%E5%9B%A0%E4%B8%BA%E6%94%BE%E5%9C%A8%20%E5%86%85%E5%AD%98%20%E4%B8%AD%EF%BC%8C%E5%B1%95%E7%A4%BA%E4%BC%9A%E6%9B%B4%20%E2%80%9C%E5%BF%AB%E2%80%9D%EF%BC%8C%E5%BF%AB%E7%9A%84%E5%8E%9F%E5%9B%A0%E6%9C%89%E4%B8%A4%E7%82%B9%EF%BC%8C%E5%A6%82%E4%B8%8B%E6%89%80%E7%A4%BA%EF%BC%9A1%EF%BC%89%E3%80%81%E7%A1%AC%E4%BB%B6%E5%BF%AB%EF%BC%9A%E5%86%85%E5%AD%98%E6%9C%AC%E8%BA%AB%E8%AF%BB%E5%8F%96%E3%80%81%E5%AD%98%E5%85%A5%E9%80%9F%E5%BA%A6%E5%BF%AB%E3%80%822%EF%BC%89%E3%80%81%E5%A4%8D%E7%94%A8%E5%BF%AB%EF%BC%9A%E8%A7%A3%E7%A0%81%E6%88%90%E6%9E%9C%E6%9C%89%E6%95%88%E4%BF%9D%E5%AD%98%EF%BC%8C%E5%A4%8D%E7%94%A8%E6%97%B6%EF%BC%8C%E7%9B%B4%E6%8E%A5%E4%BD%BF%E7%94%A8%E8%A7%A3%E7%A0%81%E5%90%8E%E5%AF%B9%E8%B1%A1%EF%BC%8C%E8%80%8C%E4%B8%8D%E6%98%AF%E5%86%8D%E5%81%9A%E4%B8%80%E6%AC%A1%E5%9B%BE%E5%83%8F%E8%A7%A3%E7%A0%81%E3%80%82" target="_blank" class="item-share weibo ">
                                <span><i class="text-lg iconfont icon-weibo-fill"></i></span>
                            </a>
                        </div>
                        <div class="col">
                            <a href="javascript:" class="item-share weixin single-popup" data-img="/qrcode?data=http%3A//gank.io/post/5e79880393b891c522d3bde6" data-title="微信扫一扫 分享朋友圈" data-desc="在微信中请长按二维码">
                                <span><i class="text-lg iconfont icon-wechat-fill"></i></span>
                            </a>
                        </div>
                        <div class="col">
                            <a href="https://connect.qq.com/widget/shareqq/index.html?url=http%3A//gank.io/post/5e79880393b891c522d3bde6%3FAndroid%E7%BB%99%E6%AF%8F%E4%B8%AA%E5%BA%94%E7%94%A8%E8%BF%9B%E7%A8%8B%E5%88%86%E9%85%8D%E7%9A%84%E5%86%85%E5%AD%98%E9%83%BD%E6%98%AF%E9%9D%9E%E5%B8%B8%E6%9C%89%E9%99%90%E7%9A%84%EF%BC%8C%E9%82%A3%E4%B9%88%EF%BC%8C%E4%B8%BA%E4%BB%80%E4%B9%88%E4%B8%8D%E8%83%BD%E6%8A%8A%E5%9B%BE%E7%89%87%E4%B8%8B%E8%BD%BD%E4%B8%8B%E6%9D%A5%E9%83%BD%E6%94%BE%E5%88%B0%E7%A3%81%E7%9B%98%E4%B8%AD%E5%91%A2%EF%BC%9F%E9%82%A3%E6%98%AF%E5%9B%A0%E4%B8%BA%E6%94%BE%E5%9C%A8%20%E5%86%85%E5%AD%98%20%E4%B8%AD%EF%BC%8C%E5%B1%95%E7%A4%BA%E4%BC%9A%E6%9B%B4%20%E2%80%9C%E5%BF%AB%E2%80%9D%EF%BC%8C%E5%BF%AB%E7%9A%84%E5%8E%9F%E5%9B%A0%E6%9C%89%E4%B8%A4%E7%82%B9%EF%BC%8C%E5%A6%82%E4%B8%8B%E6%89%80%E7%A4%BA%EF%BC%9A1%EF%BC%89%E3%80%81%E7%A1%AC%E4%BB%B6%E5%BF%AB%EF%BC%9A%E5%86%85%E5%AD%98%E6%9C%AC%E8%BA%AB%E8%AF%BB%E5%8F%96%E3%80%81%E5%AD%98%E5%85%A5%E9%80%9F%E5%BA%A6%E5%BF%AB%E3%80%822%EF%BC%89%E3%80%81%E5%A4%8D%E7%94%A8%E5%BF%AB%EF%BC%9A%E8%A7%A3%E7%A0%81%E6%88%90%E6%9E%9C%E6%9C%89%E6%95%88%E4%BF%9D%E5%AD%98%EF%BC%8C%E5%A4%8D%E7%94%A8%E6%97%B6%EF%BC%8C%E7%9B%B4%E6%8E%A5%E4%BD%BF%E7%94%A8%E8%A7%A3%E7%A0%81%E5%90%8E%E5%AF%B9%E8%B1%A1%EF%BC%8C%E8%80%8C%E4%B8%8D%E6%98%AF%E5%86%8D%E5%81%9A%E4%B8%80%E6%AC%A1%E5%9B%BE%E5%83%8F%E8%A7%A3%E7%A0%81%E3%80%82" target="_blank" class="item-share qq">
                                <span><i class="text-lg iconfont icon-qq-fill"></i></span>
                            </a>
                        </div>
                    </div>
                </div>
            </div>
        </div>
    </div>
    
    <div class="mt-3" id="apollo-postlike-section">
        <div class="avatar-group">
            
                
                <a class="flex-avatar w-32">
                    <img alt="" src="./干货集中营_files/Ueaebceb2c730411687659dac36e73cb52.jpg" class="avatar avatar-32 photo loaded" height="32" width="32" data-nclazyload="true" data-was-processed="true"></a>
            
                
                <a class="flex-avatar w-32">
                    <img alt="" src="./干货集中营_files/U8aff11e32a514aa7a15a89d125da545fP.jpg" class="avatar avatar-32 photo loaded" height="32" width="32" data-nclazyload="true" data-was-processed="true"></a>
            
                
                <a class="flex-avatar w-32">
                    <img alt="" src="./干货集中营_files/Ub9f0a62887f04f59b363d2cedd26047cA.jpg" class="avatar avatar-32 photo loaded" height="32" width="32" data-nclazyload="true" data-was-processed="true"></a>
            
                
                <a class="flex-avatar w-32">
                    <img alt="" src="./干货集中营_files/U422fc5a8b10e4c7092c570b6677d22ceA.jpg" class="avatar avatar-32 photo loaded" height="32" width="32" data-nclazyload="true" data-was-processed="true"></a>
            
                
                <a class="flex-avatar w-32">
                    <img alt="" src="./干货集中营_files/U753ba5980dfe4c3e9be14a34fab5eba4u.jpg" class="avatar avatar-32 photo loaded" height="32" width="32" data-nclazyload="true" data-was-processed="true"></a>
            
                
                <a class="flex-avatar w-32">
                    <img alt="" src="./干货集中营_files/U7ec3aaea34d54b07838607f61cef51f8k.jpg" class="avatar avatar-32 photo loaded" height="32" width="32" data-nclazyload="true" data-was-processed="true"></a>
            
                
                <a class="flex-avatar w-32">
                    <img alt="" src="./干货集中营_files/Uba061a2c0ab94d6cab7304b06b3f9507t.jpg" class="avatar avatar-32 photo loaded" height="32" width="32" data-nclazyload="true" data-was-processed="true"></a>
            
                
                <a class="flex-avatar w-32">
                    <img alt="" src="./干货集中营_files/Ubb2f92767f9f483ea5b0123b4bc6790cx.jpg" class="avatar avatar-32 photo loaded" height="32" width="32" data-nclazyload="true" data-was-processed="true"></a>
            
                
                <a class="flex-avatar w-32">
                    <img alt="" src="./干货集中营_files/U526089d87b3d4948b1c3e5acfcc821f3X.jpg" class="avatar avatar-32 photo loaded" height="32" width="32" data-nclazyload="true" data-was-processed="true"></a>
            
                
                <a class="flex-avatar w-32">
                    <img alt="" src="./干货集中营_files/U51bb0f61b217434a844f0c0f3a631eef4.jpg" class="avatar avatar-32 photo loaded" height="32" width="32" data-nclazyload="true" data-was-processed="true"></a>
            
            <span class="text-muted text-xs mx-2">
                 等 11 人赞过</span>
        </div>
    </div>

</div>
    </div>
    
    <div class="post-tags block d-flex text-sm p-4 "><i class="text-xl text-primary iconfont icon-price-tag--line mr-3"></i>
        <div class="flex-fill"><span class="d-inline-block text-muted mr-2"># <a href="https://gank.io/special/Android" rel="tag">Android</a></span></div>
    </div>
    
<div id="comments" class="comments">
    <div class="mx-1 my-3">
        <i class="text-xl text-primary iconfont icon-message--line mr-2"></i>
        评论 <small class="font-theme text-muted">(0)</small></div>
    <div class="card">
        <div class="card-body">
            <div id="respond" class="comment-respond">
                
                    <div class="logged-in-as rounded bg-light text-center p-4 p-md-5 ">
                        <div class="text-muted text-sm mb-3">请登录以参与评论。</div>
                        <a class="btn btn-primary btn-sm btn-rounded" href="https://gank.io/login">立即登录</a>
                    </div>
                
            </div>
            <ul class="comment-list mt-3 mt-md-5">
                
            </ul>
        </div>
    </div>
</div>
<!-- #comments -->
</div>
            
            
            
                <div class="sidebar col-lg-4 pl-lg-4 pl-xl-5 d-none d-lg-block" style="position: relative; overflow: visible; box-sizing: border-box; min-height: 53217px;">
    
    
    
        
    
    
        
    
    


<div class="theiaStickySidebar" style="padding-top: 0px; padding-bottom: 1px; position: fixed; transform: translateY(-817px); top: 0px; width: 322px; left: 1072.56px;"><div id="search-3" class="card card-sm widget widget_search">
    <form role="search" method="get" class="search-form" action="https://gank.io/search">
        <label>
            <span class="screen-reader-text">搜索：</span>
            <input type="search" class="search-field" placeholder="搜索…" value="" name="s">
        </label>
        <input type="submit" class="search-submit" value="搜索">
    </form>
</div><div id="custom_html-2" class="widget_text card card-sm widget widget_custom_html">
    <div class="card-header widget-header">关注我们 么么哒！<i class="bg-primary"></i></div>
    <div class="textwidget custom-html-widget">
        <div class="widget suxingme_social">
            <div class="attentionus">
                <ul class="items clearfix">
                    <span class="social-widget-link social-link-weibo">
                        <span class="social-widget-link-count">
                            <i class="iconfont icon-wechat-fill"></i>
                            微信群二维码
                        </span>
                        <span class="social-widget-link-title">微信干货交流群</span>
                        <a href="javascript:" data-img="/images/933ff2096df248598f9961dada83e70c" data-title="干货集中营微信交流群" data-desc="微信订阅号:干货集中营/gank_io" class="single-popup">
                        </a>
                    </span>

                    <span class="social-widget-link social-link-qq">
                        <span class="social-widget-link-count">
                            <i class="iconfont icon-qq"></i>
                            322189026
                        </span>
                        <span class="social-widget-link-title">QQ干货交流群</span>
                     </span>

                    <span class="social-widget-link social-link-email">
                        <span class="social-widget-link-count">
                            <i class="iconfont icon-mail-line"></i>
                            lijinshanmx@gmail.com
                        </span>
                        <span class="social-widget-link-title">投稿联系邮箱</span>
                        <a href="https://mail.qq.com/cgi-bin/qm_share?t=qm_mailme&amp;email=lijinshanmx@gmail.com" target="_blank" rel="nofollow noopener noreferrer">
                        </a>
                     </span>
                </ul>
            </div>

        </div>
    </div>
</div><div id="recommended_posts-5" class="card card-sm widget Recommended_Posts">
    <div class="card-header widget-header">本周浏览最多文章<i class="bg-primary"></i></div>
    
        <div class="card-body">
            <div class="list-grid list-rounded my-n2">
                
                    <div class="list-item py-2">
                        <div class="media media-3x2 col-4 mr-3">
                            <a class="media-content" href="https://gank.io/post/5e78b2f65d7c47fe610b0029" target="_blank" style="background-image:url(&#39;/images/9a91a5f16f9749638c0ba6ab2e1a3127&#39;)"></a>
                        </div>
                        <div class="list-content py-0">
                            <div class="list-body">
                                <a href="https://gank.io/post/5e78b2f65d7c47fe610b0029" target="_blank" class="list-title h-2x">给 Android 开发者的 RxJava 详解</a>
                            </div>
                            <div class="list-footer">
                                <div class="text-muted text-xs">
                                    <time class="d-inline-block">5年前</time>
                                </div>
                            </div>
                        </div>
                    </div>
                
                    <div class="list-item py-2">
                        <div class="media media-3x2 col-4 mr-3">
                            <a class="media-content" href="https://gank.io/post/5e7b5a8b6d2e518fdeab27aa" target="_blank" style="background-image:url(&#39;/images/fee6bd9dcd8141559c3e01c3f4b2a9d9&#39;)"></a>
                        </div>
                        <div class="list-content py-0">
                            <div class="list-body">
                                <a href="https://gank.io/post/5e7b5a8b6d2e518fdeab27aa" target="_blank" class="list-title h-2x">盘点国内那些免费好用的图床</a>
                            </div>
                            <div class="list-footer">
                                <div class="text-muted text-xs">
                                    <time class="d-inline-block">10个月前</time>
                                </div>
                            </div>
                        </div>
                    </div>
                
                    <div class="list-item py-2">
                        <div class="media media-3x2 col-4 mr-3">
                            <a class="media-content" href="https://gank.io/post/5e552d9befd6f28e2554f486" target="_blank" style="background-image:url(&#39;/images/3587b553fe10404abcce4dde1b28772c&#39;)"></a>
                        </div>
                        <div class="list-content py-0">
                            <div class="list-body">
                                <a href="https://gank.io/post/5e552d9befd6f28e2554f486" target="_blank" class="list-title h-2x">Android Studio 3.6 发布啦，快来围观</a>
                            </div>
                            <div class="list-footer">
                                <div class="text-muted text-xs">
                                    <time class="d-inline-block">11个月前</time>
                                </div>
                            </div>
                        </div>
                    </div>
                
                    <div class="list-item py-2">
                        <div class="media media-3x2 col-4 mr-3">
                            <a class="media-content" href="https://gank.io/post/5e79880393b891c522d3bde6" target="_blank" style="background-image:url(&#39;/images/8425a587dd1a4376b13a5dfe85df7166&#39;)"></a>
                        </div>
                        <div class="list-content py-0">
                            <div class="list-body">
                                <a href="https://gank.io/post/5e79880393b891c522d3bde6" target="_blank" class="list-title h-2x">深入探索 Android 内存优化（炼狱级别）</a>
                            </div>
                            <div class="list-footer">
                                <div class="text-muted text-xs">
                                    <time class="d-inline-block">10个月前</time>
                                </div>
                            </div>
                        </div>
                    </div>
                
                    <div class="list-item py-2">
                        <div class="media media-3x2 col-4 mr-3">
                            <a class="media-content" href="https://gank.io/post/5e7a03b005423f6b5b96d959" target="_blank" style="background-image:url(&#39;/images/35d2e4166dd54f0eb011ee7e473241a4&#39;)"></a>
                        </div>
                        <div class="list-content py-0">
                            <div class="list-body">
                                <a href="https://gank.io/post/5e7a03b005423f6b5b96d959" target="_blank" class="list-title h-2x">RxJava 与 Retrofit 结合的最佳实践</a>
                            </div>
                            <div class="list-footer">
                                <div class="text-muted text-xs">
                                    <time class="d-inline-block">4年前</time>
                                </div>
                            </div>
                        </div>
                    </div>
                
            </div>
        </div>
    
</div><div id="recommended_posts-5" class="card card-sm widget Recommended_Posts">
    <div class="card-header widget-header">本周点赞最多文章<i class="bg-primary"></i></div>
    
        <div class="card-body">
            <div class="list-grid list-rounded my-n2">
                
                    <div class="list-item py-2">
                        <div class="media media-3x2 col-4 mr-3">
                            <a class="media-content" href="https://gank.io/post/5e78b2f65d7c47fe610b0029" target="_blank" style="background-image:url(&#39;/images/9a91a5f16f9749638c0ba6ab2e1a3127&#39;)"></a>
                        </div>
                        <div class="list-content py-0">
                            <div class="list-body">
                                <a href="https://gank.io/post/5e78b2f65d7c47fe610b0029" target="_blank" class="list-title h-2x">给 Android 开发者的 RxJava 详解</a>
                            </div>
                            <div class="list-footer">
                                <div class="text-muted text-xs">
                                    <time class="d-inline-block">5年前</time>
                                </div>
                            </div>
                        </div>
                    </div>
                
                    <div class="list-item py-2">
                        <div class="media media-3x2 col-4 mr-3">
                            <a class="media-content" href="https://gank.io/post/5e552d9befd6f28e2554f486" target="_blank" style="background-image:url(&#39;/images/3587b553fe10404abcce4dde1b28772c&#39;)"></a>
                        </div>
                        <div class="list-content py-0">
                            <div class="list-body">
                                <a href="https://gank.io/post/5e552d9befd6f28e2554f486" target="_blank" class="list-title h-2x">Android Studio 3.6 发布啦，快来围观</a>
                            </div>
                            <div class="list-footer">
                                <div class="text-muted text-xs">
                                    <time class="d-inline-block">11个月前</time>
                                </div>
                            </div>
                        </div>
                    </div>
                
                    <div class="list-item py-2">
                        <div class="media media-3x2 col-4 mr-3">
                            <a class="media-content" href="https://gank.io/post/5e50eaf6a4f7880ef87b35f2" target="_blank" style="background-image:url(&#39;/images/01b635252da7418c900b720f5a42f327&#39;)"></a>
                        </div>
                        <div class="list-content py-0">
                            <div class="list-body">
                                <a href="https://gank.io/post/5e50eaf6a4f7880ef87b35f2" target="_blank" class="list-title h-2x">2020年关于Android开发架构，我们还能做些什么？</a>
                            </div>
                            <div class="list-footer">
                                <div class="text-muted text-xs">
                                    <time class="d-inline-block">1年前</time>
                                </div>
                            </div>
                        </div>
                    </div>
                
                    <div class="list-item py-2">
                        <div class="media media-3x2 col-4 mr-3">
                            <a class="media-content" href="https://gank.io/post/5e552d00efd6f28e2554f482" target="_blank" style="background-image:url(&#39;/images/f3c8eee737d84a3b8e17b517a13ee4b7&#39;)"></a>
                        </div>
                        <div class="list-content py-0">
                            <div class="list-body">
                                <a href="https://gank.io/post/5e552d00efd6f28e2554f482" target="_blank" class="list-title h-2x">跨平台技术趋势及字节跳动 Flutter 架构实践 | Flutter 沙龙回顾</a>
                            </div>
                            <div class="list-footer">
                                <div class="text-muted text-xs">
                                    <time class="d-inline-block">1年前</time>
                                </div>
                            </div>
                        </div>
                    </div>
                
                    <div class="list-item py-2">
                        <div class="media media-3x2 col-4 mr-3">
                            <a class="media-content" href="https://gank.io/post/5e7990d81e12e48ff711862e" target="_blank" style="background-image:url(&#39;/images/48c898d46629447d8cfbf690100f2d2d&#39;)"></a>
                        </div>
                        <div class="list-content py-0">
                            <div class="list-body">
                                <a href="https://gank.io/post/5e7990d81e12e48ff711862e" target="_blank" class="list-title h-2x">（建议精读）HTTP灵魂之问，巩固你的 HTTP 知识体系</a>
                            </div>
                            <div class="list-footer">
                                <div class="text-muted text-xs">
                                    <time class="d-inline-block">10个月前</time>
                                </div>
                            </div>
                        </div>
                    </div>
                
            </div>
        </div>
    
</div><div id="tag_cloud-2" class="card card-sm widget widget_tag_cloud">
    <div class="card-header widget-header">标签云<i class="bg-primary"></i></div>
    <div class="tagcloud">
        <a href="https://gank.io/ganhuo/Android" target="_blank" class="tag-cloud-link tag-link-37 tag-link-position-1" style="font-size: 20.826589595376pt;">Android干货
        </a>
        <a href="https://gank.io/special/Android" target="_blank" class="tag-cloud-link tag-link-37 tag-link-position-1" style="font-size: 20.826589595376pt;">Android专题
        </a>
        <a href="https://gank.io/special/Girl" target="_blank" class="tag-cloud-link tag-link-37 tag-link-position-1" style="font-size: 20.826589595376pt;">妹纸
        </a>
        <a href="https://gank.io/ganhuo/iOS" target="_blank" class="tag-cloud-link tag-link-37 tag-link-position-1" style="font-size: 20.826589595376pt;">iOS干货
        </a>
        <a href="https://gank.io/special/iOS" target="_blank" class="tag-cloud-link tag-link-37 tag-link-position-1" style="font-size: 20.826589595376pt;">iOS专题
        </a>
        <a href="https://gank.io/ganhuo/Flutter" target="_blank" class="tag-cloud-link tag-link-37 tag-link-position-1" style="font-size: 20.826589595376pt;">Flutter干货
        </a>
    </div>
</div><div class="resize-sensor" style="position: absolute; inset: 0px; overflow: hidden; z-index: -1; visibility: hidden;"><div class="resize-sensor-expand" style="position: absolute; left: 0; top: 0; right: 0; bottom: 0; overflow: hidden; z-index: -1; visibility: hidden;"><div style="position: absolute; left: 0px; top: 0px; transition: all 0s ease 0s; width: 332px; height: 1548px;"></div></div><div class="resize-sensor-shrink" style="position: absolute; left: 0; top: 0; right: 0; bottom: 0; overflow: hidden; z-index: -1; visibility: hidden;"><div style="position: absolute; left: 0; top: 0; transition: 0s; width: 200%; height: 200%"></div></div></div></div></div>
            
        </div>
    </div>
</main>
<footer class="footer bg-dark py-3 py-lg-4">
    <div class="container">
        <div class="d-md-flex flex-md-fill align-items-md-center">
            <div class="d-md-flex flex-md-column">
                <ul class="footer-menu">
                    <li id="menu-item-12688" class="menu-item menu-item-type-custom menu-item-object-custom menu-item-12688"><a href="https://gank.io/">主页</a></li>
                </ul>
                <div class="footer-copyright text-xs">
                    Copyright © 2015-2020 <a href="https://gank.io/" title="干货集中营" rel="home">干货集中营</a> gank.io
                    <a href="https://beian.miit.gov.cn/" target="_blank" rel="nofollow" class="d-none d-lg-inline-block">沪ICP备13038357号-9</a>
                </div>
            </div>
            <div class="flex-md-fill"></div>
            <div class="mt-3 mt-md-0">
                <a href="javascript:" data-img="/images/a045269e8c52443b82fd654786a625f2" data-title="干货集中营QQ交流群" data-desc="扫一扫，立即加入我们" class="single-popup btn btn-secondary btn-qq btn-icon">
                    <span><i class="text-lg iconfont icon-qq-fill"></i></span>
                </a>
                <a href="javascript:" data-img="/images/933ff2096df248598f9961dada83e70c" data-title="干货集中营微信交流群" data-desc="微信订阅号:干货集中营/gank_io" class="single-popup btn btn-secondary btn-weixin btn-icon">
                    <span><i class="text-lg iconfont icon-wechat-fill"></i></span>
                </a>
                <a href="https://weibo.com/u/5576601806" rel="nofollow" target="_blank" class="btn btn-secondary btn-weibo btn-icon">
                    <span><i class="text-lg iconfont icon-weibo-fill"></i></span>
                </a>
                <a href="mailto:lijinshanmx@gmail.com" class="btn btn-secondary btn-mail btn-icon">
                    <span><i class="text-lg iconfont icon-mail-fill"></i></span>
                </a>
            </div>
        </div>
        
    </div>
</footer>
<a href="javascript:void(0)" id="scroll_to_top" class="btn btn-primary btn-icon scroll-to-top" style="display: block;"><span><i class="text-lg iconfont icon-arrow-up-fill"></i></span></a>
<div class="mobile-overlay"></div>
<script type="text/javascript" src="./干货集中营_files/smartideo.js.下载"></script>
<script type="text/javascript" src="./干货集中营_files/jimu.js.下载"></script>
<script type="text/javascript" src="./干货集中营_files/bootstrap.min.js.下载"></script>
<script type="text/javascript" src="./干货集中营_files/plugins.min.js.下载"></script>
<script type="text/javascript" src="./干货集中营_files/owl.carousel.min.js.下载"></script>
<script type="text/javascript" src="./干货集中营_files/ResizeSensor.min.js.下载"></script>
<script type="text/javascript" src="./干货集中营_files/theia-sticky-sidebar.min.js.下载"></script>
<script type="text/javascript" src="./干货集中营_files/ncietheme.js.下载"></script>
<script type="text/javascript" src="./干货集中营_files/ajax-comment.js.下载"></script>
<script type="text/javascript" src="./干货集中营_files/wp-embed.min.js.下载"></script>
<script type="text/javascript" src="./干货集中营_files/cursor.js.下载"></script>


</body></html>